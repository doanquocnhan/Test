//======================================================================
// 分析を行う分析エージェントクラス
//----------------------------------------------------------------------
//  SYSTEM    : Clinical Search
//  SUB SYSTEM: Clinical Search Core
//  FILE      : SearchAgent.cs
//----------------------------------------------------------------------
//  Copyright(C) 2005 株式会社 医用工学研究所. All rights reserved.
//======================================================================
using System;
using System.Data;
using System.IO;
using System.Threading;
using System.Text;
using System.Linq;
using MEI.Library.CanDb;
using System.Xml.Serialization;
using System.Configuration;
using ClinicalDataAnalyzer.RemoteInterfaces;
using System.Collections;
using ClinicalDataAnalyzer.ArcLib;
using System.Collections.Generic;
using System.Diagnostics;

namespace ClinicalSearch.Core
{
	/// <summary>
	/// 非同期用デリゲート
	/// </summary>
	delegate CANWErr MyDelegate(string param1, AnalyzeConfigTypeEnum param2, byte[] param3, long param4, long param5, long param6, string param7);
	
	/// <summary>
	/// 分析エージェント
	/// </summary>
	public class SearchAgent
	{
		MyDelegate		m_searchDelegate;
		IAsyncResult	m_iAsyncResult;

		DateTime		m_accessDate;
		long			m_searchHistoryId;
		int				m_maxDataCnt;
		int				m_divisionRange;
		int				m_maxResultOrder;
		int				m_maxSqlLength;
		string			m_ipAddress;
		int				m_resultSearchOrder;

		// 状態管理
		List<int>		m_successSearchOrders;
		List<int>		m_progressRateList;
		List<int>		m_dataCntList;
		bool			m_cancelRequest;
		CANWErr         m_canwErr;

        /// <summary>
        /// 扱うことのできる最小日時
        /// </summary>
        private readonly DateTime MIN_DATE = new DateTime(1840, 12, 31, 0, 0, 0);

		/// <summary>
		/// エージェント参照
		/// </summary>
		public IAsyncResult IAsyncResult
		{
			get
			{
				return m_iAsyncResult;
			}
			set
			{
				m_iAsyncResult = value;
			}
		}

		/// <summary>
		/// 検索が完了した検索順序の一覧（参照用）
		/// </summary>
		public List<int> SuccessSearchOrders
		{
			get
			{
				return m_successSearchOrders;
			}
		}

		/// <summary>
		/// 検索結果（最終結果）のSearchOrder
		/// </summary>
		public int ResultSearchOrder
		{
			get
			{
				return m_resultSearchOrder;
			}
		}

		/// <summary>
		/// 進捗率のリスト
		/// </summary>
		public List<int> ProgressRateList
		{
			get
			{
				return m_progressRateList;
			}
		}

		/// <summary>
		/// データカウントのリスト
		/// </summary>
		public List<int> DataCntList
		{
			get
			{
				return m_dataCntList;
			}
		}

		/// <summary>
		/// 実行状態（CANWErrのCANWErrCodeとMessageを参照）
		/// </summary>
		public CANWErr CANWErr
		{
			get
			{
				return m_canwErr;
			}
		}

		/// <summary>
		/// キャンセル依頼（外部からの依頼・参照用）
		/// </summary>
		public bool CancelRequest
		{
			get
			{
				return m_cancelRequest;
			}
		}

        /// <summary>
        /// 完了ページ数一覧
        /// </summary>
        private List<int> CompletedPageCounts { get; set; }

		/// <summary>
		/// 読み取り用 SQL Command を取得または設定します。
		/// </summary>
		private CanDbCommand ReadCommand { get; set; }

		/// <summary>
		/// コンストラクタ
		/// </summary>
		public SearchAgent()
		{
			Initialize();
		}

		/// <summary>
		/// 初期化
		/// </summary>
		private void Initialize()
		{
			m_accessDate = DateTime.Now;
			m_searchDelegate = null;
			m_iAsyncResult = null;
			m_searchHistoryId = 0;
			m_maxDataCnt = 0;
			m_divisionRange = 0;
			m_maxSqlLength = 0;
			m_ipAddress = "";
			m_successSearchOrders = new List<int>();
			m_progressRateList = new List<int>();
			m_dataCntList = new List<int>();
			m_cancelRequest = false;
			m_canwErr = new CANWErr(CANWErrCode.StillSearch, "");

            this.CompletedPageCounts = new List<int>();
		}

		/// <summary>
		/// アクセス日時
		/// </summary>
		public DateTime AccessDate
		{
			get
			{
				return m_accessDate;
			}
		}

		/// <summary>
		/// 検索Agentのアクセス日時を更新してAgentを生存させる
		/// </summary>
		public void UpdateAccessDate()
		{
			m_accessDate = DateTime.Now;
		}

		/// <summary>
		/// 検索処理を開始する
		/// </summary>
		/// <param name="sessionId">セッションID</param>
		/// <param name="searchSettingComp">検索条件のバイナリデータ</param>
		/// <param name="analyzeConfigId">検索テンプレートID</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="maxDataCnt">最大件数</param>
		/// <param name="divisionRange">1ページあたりの最大件数</param>
		/// <param name="maxSqlLength">SQLの最大バイト長</param>
		/// <param name="ipAddress">IPアドレス</param>
		/// <param name="userId">ユーザID</param>
		/// <param name="loginId">ログインID</param>
		/// <returns></returns>
		public CANWErr ExecuteSearch(string sessionId, byte[] searchSettingComp, long analyzeConfigId, long searchHistoryId, int maxDataCnt, int divisionRange, int maxSqlLength, string ipAddress, long userId, string loginId)
		{
			CANWErr err = new CANWErr(CANWErrCode.Success);
			m_canwErr = new CANWErr(CANWErrCode.StillSearch, "");
			try
			{
				// 現在の日時をアクセス情報として残す
				UpdateAccessDate();
				// 検索が始まっているかどうか
				if (m_iAsyncResult == null)
				{
					m_searchHistoryId = searchHistoryId;
					m_maxDataCnt = maxDataCnt;
					m_divisionRange = divisionRange;
					m_maxResultOrder = ((int)(m_maxDataCnt / m_divisionRange)) + 1;
					m_maxSqlLength = maxSqlLength;
					m_ipAddress = ipAddress;

					// デリゲートの作成及び非同期処理の開始
					m_searchDelegate = new MyDelegate(this.SearchProc);
					m_iAsyncResult = m_searchDelegate.BeginInvoke(sessionId, AnalyzeConfigTypeEnum.SearchSetting, searchSettingComp, analyzeConfigId, searchHistoryId, userId, loginId, new AsyncCallback(this.CompletedAgent), null);
				}
				else
				{
					err.Code = CANWErrCode.AlreadySearch;
				}
			}
			catch (Exception ex)
			{
				err.Code = CANWErrCode.System;
				err.Message = ex.Message;
			}
			return err;
        }

		/// <summary>
		/// スクリーニング検索の検索実行
		/// </summary>
		/// <param name="sessionId">セッションID</param>
		/// <param name="screeningSearchSetting">検索条件のバイナリデータ</param>
		/// <param name="analyzeConfigId">検索テンプレートID</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="maxDataCnt">最大件数</param>
		/// <param name="divisionRange">1ページあたりの最大件数</param>
		/// <param name="maxSqlLength">SQLの最大バイト長</param>
		/// <param name="ipAddress">IPアドレス</param>
		/// <param name="userId">ユーザID</param>
		/// <param name="loginId">ログインID</param>
		/// <returns>Can用エラークラス</returns>
		public CANWErr ExecuteScreeningSearch(string sessionId, byte[] screeningSearchSetting, long analyzeConfigId, long searchHistoryId, int maxDataCnt, int divisionRange, int maxSqlLength, string ipAddress, long userId, string loginId)
		{
			CANWErr err = new CANWErr(CANWErrCode.Success);
			m_canwErr = new CANWErr(CANWErrCode.StillSearch, "");

			try
			{
				// 現在の日時をアクセス情報として残す
				UpdateAccessDate();

				// 検索が始まっているかどうか
				if (m_iAsyncResult == null)
				{
					m_maxDataCnt = maxDataCnt;
					m_divisionRange = divisionRange;
					m_maxResultOrder = ((int)(m_maxDataCnt / m_divisionRange)) + 1;
					m_maxSqlLength = maxSqlLength;
					m_ipAddress = ipAddress;

					m_searchHistoryId = searchHistoryId;
					// デリゲートの作成及び非同期処理の開始
					m_searchDelegate = new MyDelegate(this.ScreeningSearchProc);
                    m_iAsyncResult = m_searchDelegate.BeginInvoke(sessionId, AnalyzeConfigTypeEnum.ScreeningSearchSetting, screeningSearchSetting, analyzeConfigId, searchHistoryId, userId, loginId, new AsyncCallback(this.CompletedAgent), null);
				}
				else
				{
					err.Code = CANWErrCode.AlreadySearch;
				}
			}
			catch (Exception ex)
			{
				err.Code = CANWErrCode.System;
				err.Message = ex.Message;
			}
			return err;
		}

		/// <summary>
		/// 結合結果(掛け算表示)の検索実行
		/// </summary>
		/// <param name="sessionId">セッションID</param>
		/// <param name="screeningSearchSetting">検索条件のバイナリデータ</param>
		/// <param name="analyzeConfigId">検索テンプレートID</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="maxDataCnt">最大件数</param>
		/// <param name="divisionRange">1ページあたりの最大表示件数</param>
		/// <param name="maxSqlLength">SQLの最大バイト長</param>
		/// <param name="ipAddress">IPアドレス</param>
		/// <param name="userId">ユーザID</param>
		/// <param name="loginId">ログインID</param>
		/// <returns>Can用エラークラス</returns>
		public CANWErr ExecuteSearchJoin(string sessionId, byte[] screeningSearchSetting, long analyzeConfigId, long searchHistoryId, int maxDataCnt, int divisionRange, int maxSqlLength, string ipAddress, long userId, string loginId)
		{
			CANWErr err = new CANWErr(CANWErrCode.Success);
			m_canwErr = new CANWErr(CANWErrCode.StillSearch, "");

			try
			{
				// 現在の日時をアクセス情報として残す
				UpdateAccessDate();

				// 検索が始まっているかどうか
				if (m_iAsyncResult == null)
				{
					m_maxDataCnt = maxDataCnt;
					m_divisionRange = divisionRange;
					m_maxResultOrder = ((int)(m_maxDataCnt / m_divisionRange)) + 1;
					m_maxSqlLength = maxSqlLength;
					m_ipAddress = ipAddress;

					m_searchHistoryId = searchHistoryId;
					// デリゲートの作成及び非同期処理の開始
					m_searchDelegate = new MyDelegate(this.SearchJoinProc);
                    m_iAsyncResult = m_searchDelegate.BeginInvoke(sessionId, AnalyzeConfigTypeEnum.ScreeningSearchSetting, screeningSearchSetting, analyzeConfigId, searchHistoryId, userId, loginId, new AsyncCallback(this.CompletedAgent), null);
				}
				else
				{
					err.Code = CANWErrCode.AlreadySearch;
				}
			}
			catch (Exception ex)
			{
				err.Code = CANWErrCode.System;
				err.Message = ex.Message;
			}
			return err;

		}

		/// <summary>
		/// 検索処理の進捗確認
		/// </summary>
		/// <param name="progressRate">進捗率</param>
        /// <param name="dataCnt">データ件数</param>
        /// <param name="totalDataCount">検索結果数</param>
        /// <param name="completedPageCount">完了ページ数</param>
		/// <returns>Can用エラークラス</returns>
		public CANWErr CheckSearchProcFinish(out int progressRate, out int dataCnt, out int totalDataCount, out int completedPageCount)
		{
			CANWErr		err = new CANWErr(CANWErrCode.StillSearch);

			progressRate = 0;
			dataCnt = 0;

            // 検索結果数
            totalDataCount = 0;
            // 完了ページ数
            completedPageCount = 0;

			if (m_iAsyncResult != null)
			{
				UpdateAccessDate();

				if (!m_iAsyncResult.IsCompleted)
				{
					// 進捗率とデータ件数を取得する(途中でも取得する）
					if (m_progressRateList.Count > m_resultSearchOrder &&
						m_dataCntList.Count > m_resultSearchOrder)
					{
						progressRate = m_progressRateList[m_resultSearchOrder];
						dataCnt = m_dataCntList[m_resultSearchOrder];
					}

                    if (this.m_dataCntList.Count > m_resultSearchOrder)
                    {
                        totalDataCount = this.m_dataCntList[m_resultSearchOrder];
                    }

                    if (this.CompletedPageCounts.Count > m_resultSearchOrder)
                    {
                        completedPageCount = this.CompletedPageCounts[m_resultSearchOrder];
                    }
				}
				else
				{
					err = m_searchDelegate.EndInvoke(m_iAsyncResult);
					switch (m_canwErr.Code)
					{
						case CANWErrCode.Success:
							// 進捗率とデータ件数を取得する
							if (m_progressRateList.Count > m_resultSearchOrder &&
								m_dataCntList.Count > m_resultSearchOrder)
							{
								progressRate = m_progressRateList[m_resultSearchOrder];
								dataCnt = m_dataCntList[m_resultSearchOrder];
							}

                            if (this.m_dataCntList.Count > m_resultSearchOrder)
                            {
                                totalDataCount = this.m_dataCntList[m_resultSearchOrder];
                            }

                            if (this.CompletedPageCounts.Count > m_resultSearchOrder)
                            {
                                completedPageCount = this.CompletedPageCounts[m_resultSearchOrder];
                            }
							// 成功時にエージェントのリストを削除の上SearchProc_TBLを削除
							
							break;
						case CANWErrCode.StillSearch:
							// 進捗率とデータ件数を取得する
							if (m_progressRateList.Count > m_resultSearchOrder &&
								m_dataCntList.Count > m_resultSearchOrder)
							{
								progressRate = m_progressRateList[m_resultSearchOrder];
                                dataCnt = m_dataCntList[m_resultSearchOrder];
							}

                            if (this.m_dataCntList.Count > m_resultSearchOrder)
                            {
                                totalDataCount = this.m_dataCntList[m_resultSearchOrder];
                            }

                            if (this.CompletedPageCounts.Count > m_resultSearchOrder)
                            {
                                completedPageCount = this.CompletedPageCounts[m_resultSearchOrder];
                            }
							break;
						default:
							err.Code = m_canwErr.Code;
							err.Message = m_canwErr.Message;
							break;
					}
				}
			}
			else
			{
				err.Code = CANWErrCode.NoSearch;
			}

			return err;
		}

		/// <summary>
		/// スクリーニング検索の進捗確認
		/// </summary>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="progressRate">進捗率</param>
		/// <param name="dataCnt">データ件数</param>
        /// <param name="totalDataCount">検索結果数</param>
        /// <param name="completedPageCount">完了済みページ数</param>
		/// <returns>Can用エラークラス</returns>
		public CANWErr CheckScreeningSearchPartFinish(int searchOrder, out int progressRate, out int dataCnt, out int totalDataCount, out int completedPageCount)
		{
			CANWErr		err = new CANWErr(CANWErrCode.StillSearch);

			progressRate = 0;
			dataCnt = 0;

            // 検索結果数
            totalDataCount = 0;
            // 完了済みページ数
            completedPageCount = 0;

			if (m_iAsyncResult != null)
			{
				UpdateAccessDate();

				switch (m_canwErr.Code)
				{
					case CANWErrCode.Success:
					case CANWErrCode.StillSearch:
						if (m_successSearchOrders.Count > searchOrder)
						{
							err.Code = CANWErrCode.Success;
						}
						else
						{
							err.Code = CANWErrCode.StillSearch;
						}
						// 進捗率とデータ件数を取得する
						if ( m_progressRateList.Count > searchOrder && m_dataCntList.Count > searchOrder)
						{
							progressRate = m_progressRateList[searchOrder];
							dataCnt = m_dataCntList[searchOrder];
						}

                        if (this.m_dataCntList.Count > searchOrder)
                        {
                            totalDataCount = this.m_dataCntList[searchOrder];
                        }

                        if (this.CompletedPageCounts.Count > searchOrder)
                        {
                            completedPageCount = this.CompletedPageCounts[searchOrder];
                        }
						break;
					default:
						err.Code = m_canwErr.Code;
						err.Message = m_canwErr.Message;
						break;
				}
			}
			else
			{
				err.Code = CANWErrCode.NoSearch;
			}
			return err;
		}

		/// <summary>
		/// 結合結果(掛け算表示)の進捗確認
		/// </summary>
		/// <param name="progressRate">進捗率</param>
		/// <param name="dataCnt">データ件数</param>
		/// <returns>Can用エラークラス</returns>
		public CANWErr CheckSearchJoinFinish(out int progressRate, out int dataCnt)
		{
			CANWErr err = new CANWErr(CANWErrCode.StillSearch);

			progressRate = 0;
			dataCnt = 0;

			if (m_iAsyncResult != null)
			{
				UpdateAccessDate();

				if (!m_iAsyncResult.IsCompleted)
				{
					// 進捗率とデータ件数を取得する(途中でも取得する）
					if (m_progressRateList.Count > m_resultSearchOrder &&
						m_dataCntList.Count > m_resultSearchOrder)
					{
						progressRate = m_progressRateList[m_resultSearchOrder];
						dataCnt = m_dataCntList[m_resultSearchOrder];
					}
				}
				else
				{
					err = m_searchDelegate.EndInvoke(m_iAsyncResult);
					switch (m_canwErr.Code)
					{
						case CANWErrCode.Success:
							// 進捗率とデータ件数を取得する
							if (m_progressRateList.Count > m_resultSearchOrder &&
								m_dataCntList.Count > m_resultSearchOrder)
							{
								progressRate = m_progressRateList[m_resultSearchOrder];
                                dataCnt = m_dataCntList[m_resultSearchOrder];
							}
							break;
						case CANWErrCode.StillSearch:
							// 進捗率とデータ件数を取得する
							if (m_progressRateList.Count > m_resultSearchOrder &&
								m_dataCntList.Count > m_resultSearchOrder)
							{
								progressRate = m_progressRateList[m_resultSearchOrder];
                                dataCnt = m_dataCntList[m_resultSearchOrder];
							}
							break;
						default:
							err.Code = m_canwErr.Code;
							err.Message = m_canwErr.Message;
							break;
					}
				}
			}
			else
			{
				err.Code = CANWErrCode.NoSearch;
			}
			return err;
		}

		/// <summary>
		/// 非同期で検索処理を行なう
		/// </summary>
		/// <param name="sessionId">セッションID</param>
		/// <param name="searchSettingComp">検索条件のバイナリデータ</param>
		/// <param name="analyzeConfigId">検索テンプレートID</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="userId">ユーザID</param>
		/// <param name="loginId">ログインID</param>
		/// <returns></returns>
		private CANWErr SearchProc(string sessionId, AnalyzeConfigTypeEnum analyzeConfigType, byte[] searchSettingComp, long analyzeConfigId, long searchHistoryId, long userId, string loginId)
		{
            CANWErr             err = new CANWErr(CANWErrCode.Success);
            Encoding            charSet = Encoding.GetEncoding("Shift_JIS");

            // note : 結果レコードの読み取り
			CanDbConnection		conn = new CanDbConnection(ClinicalSearchCoreLibs.GetConnectionStringCan());
            CanDbDataReader     dr = null;
            SqlManager          sqlManager;
            string              selectSql, insertSql;
            
            // note : 結果レコードから結果バイナリの作成
            DataSet             searchResultBuf = new DataSet();
            string[]            columnNameList, displayNameList;
            
            // note : 結果バイナリの書き込み
            CanDbConnection     connWrite = new CanDbConnection(ClinicalSearchCoreLibs.GetConnectionStringCan());
            CanDbCommand        cmdWrite = null;

			// note : ログの書き込み
			CanDbCommand        cmdLog = null;
			string				userName = "";
			string				targetDisplayName = "";
			SearchSetting30		searchSetting = null;

			int					searchOrder = 0;
			int					resultOrder = 0;
			string				procMessage = "";
			string				errMessage = "";
			CANWErrCode			procErrCode;
			
			try
			{
				conn.Open();
				connWrite.Open();
				sqlManager = new SqlManager();
				cmdWrite = new CanDbCommand("", connWrite, null);
				this.ReadCommand = new CanDbCommand("", conn, null);
				cmdLog = new CanDbCommand("", connWrite, null);

                string[] targetColumnTypes;
				string[] originalColumnTypes;
                NumericDateTimeFormat[] numericDateTimeFormats;

				// 進捗更新およびキャンセルチェック
				if (SetProgressRate(searchOrder, resultOrder, 0) && AddDataCnt(searchOrder, 0) && m_cancelRequest)
				{
					;	// キャンセル
				}
				else if (!ClinicalSearchCoreLibs.GetUserNameProc(this.ReadCommand, userId, this, out userName, out procMessage))
				{
					err.Code = CANWErrCode.System;
					errMessage = "ユーザー名の取得に失敗しました。" + procMessage;
				}
				else if (SetProgressRate(searchOrder, resultOrder, 1) && m_cancelRequest)
				{
					;	// キャンセル
				}
				// 検索セットを解凍する
				else if (!ClinicalSearchCoreLibs.ExpandSearchSetting(searchSettingComp, out searchSetting, out procMessage))
				{
					err.Code = CANWErrCode.InvalidVariable;
					errMessage = "検索条件の解凍に失敗しました。" + procMessage;
				}
				// 進捗更新およびキャンセルチェック
				else if (SetProgressRate(searchOrder, resultOrder, 2) && m_cancelRequest)
				{
					;	// キャンセル
				}
				// SearchHistory_TBLに追加する
				else if (!ClinicalSearchCoreLibs.AddSearchHistory(cmdWrite, searchHistoryId, searchSetting.TargetId, userId, analyzeConfigId, searchSettingComp, analyzeConfigType, loginId, out procMessage))
				{
					err.Code = CANWErrCode.System;
					errMessage = "検索実行前処理に失敗しました。" + procMessage;
				}
				// 進捗更新およびキャンセルチェック
				else if (SetProgressRate(searchOrder, resultOrder, 3) && m_cancelRequest)
				{
					;	// キャンセル
				}
				// 項目一覧を取得
				else if (!GetDisplayNameListProc(conn, searchSetting.TargetId, out targetDisplayName, out columnNameList, out displayNameList,
					out targetColumnTypes, out numericDateTimeFormats, out originalColumnTypes, out procMessage))
				{
					err.Code = CANWErrCode.System;
					errMessage = "検索ターゲットの項目一覧の取得に失敗しました。" + procMessage;
				}
				// 進捗更新およびキャンセルチェック
				else if (SetProgressRate(searchOrder, resultOrder, 4) && m_cancelRequest)
				{
					;   // キャンセル
				}
				// SQL文を生成（selectのみ取得される
				else if (!sqlManager.GetSearchSql(conn, searchHistoryId, searchOrder, new SearchSetting30[1] { ReplaceMinDateTime(searchSetting) },
					columnNameList.ToList(), originalColumnTypes, out selectSql, out insertSql))
				{
					err.Code = CANWErrCode.InvalidVariable;
					errMessage = "SQLの生成に失敗しました。検索条件が不正な可能性があります。";
				}
				// 進捗更新およびキャンセルチェック
				else if (SetProgressRate(searchOrder, resultOrder, 5) && m_cancelRequest)
				{
					;	// キャンセル
				}
				// SQL文のバイト数が制限値を超えているかを調べる
				else if (m_maxSqlLength > 0 && charSet.GetByteCount(selectSql) > m_maxSqlLength)
				{
					err.Code = CANWErrCode.TooLargeRequest;
					errMessage = "設定値よりもSQLが長すぎます。[" + charSet.GetByteCount(selectSql).ToString() + "バイト/" + m_maxSqlLength.ToString() + "/バイト]";
				}
				else
				{
                    this.CompletedPageCounts.Add(0);

                    // 最終結果の順序を設定しておく
                    m_resultSearchOrder = searchOrder;
                    //検索処理では使用しない(ScreeningSearchにて足し算の表示の際に使用)
                    DataTable screeningSearchResult;
                    // 結果の問い合わせを行なう関数
                    if (ReadDataAndInsertSearchHistory(this.ReadCommand, cmdWrite, dr, selectSql,
						searchHistoryId, searchOrder, loginId, columnNameList, displayNameList, targetColumnTypes,
						numericDateTimeFormats, out screeningSearchResult, out procErrCode, out errMessage))
                    {
                        // note : 成功
                        ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, "", m_ipAddress, loginId, LogType.Info, "", m_cancelRequest, true);
                    }
                    else if (errMessage.Trim().Length == 0)
                    {
                        // note : キャンセルされた
                        ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, "", m_ipAddress, loginId, LogType.Info, "検索処理を途中でキャンセルしました", m_cancelRequest, true);
                    }
                    else
                    {
                        // note : 失敗
                        ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, "", m_ipAddress, loginId, LogType.Error, errMessage, m_cancelRequest, true);
                        err.Code = procErrCode;
                    }
                }
                ClinicalSearchCoreLibs.UpdateSearchHistoryTaskRunning(cmdWrite, searchHistoryId, TaskType.Normal);
			}
			catch (CanDbException ex)
			{
				// note : DB2の場合に問い合わせたSQLのコストが高いためDBの処理がタイムアウトするとこの例外が投げられることがあるのでここで対応する
				if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "HY008"))
				{
					err.Code = CANWErrCode.Timeout;
                    errMessage = ex.Message;
				}
				// note : DB2の場合に問い合わせたSQLが長すぎるもしくは複雑すぎるとこの例外が投げられることがあるのでここで対応する
				else if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "54001"))
				{
					err.Code = CANWErrCode.TooLargeRequest;
                    errMessage = ex.Message;
				}
				else
				{
					err.Code = CANWErrCode.System;
                    errMessage = ex.Message;
				}


				EventLog.WriteEntry("Search Core Service", "SearchProc:CanDbException:【AnalyzeConfigId】" + analyzeConfigId.ToString() + "【searchHistoryId】" + searchHistoryId.ToString() + "【Message】" + ex.Message, EventLogEntryType.Error, 65535);
			}
			catch (Exception ex)
			{
				err.Code = CANWErrCode.System;
                errMessage = ex.Message;


                EventLog.WriteEntry("Search Core Service", "SearchProc:Exception:【AnalyzeConfigId】" + analyzeConfigId.ToString() + "【searchHistoryId】" + searchHistoryId.ToString() + "【Message】" + ex.Message, EventLogEntryType.Error, 65535);
			}
			finally
			{
				// note : 最後にLOG_TBLへ記載
				if (m_cancelRequest)
				{
					// note : 外部からのキャンセル依頼
					// note : SearchHistory_TBLからレコード削除
					if (ClinicalSearchCoreLibs.DeleteSearchHistory(cmdWrite, searchHistoryId, out procMessage))
					{
						// Managerへの伝達のためここでerr.Codeをキャンセルにする
						err.Code = CANWErrCode.CancelSearch;
						err.Message = "検索処理を途中でキャンセルしました。";

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行がキャンセルされました。";
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteSearch", LogType.Info, errMessage);
					}
					else
					{
						// Managerへの伝達のためここでerr.Codeをキャンセルにする
						err.Code = CANWErrCode.System;
						err.Message = "検索処理のキャンセルに失敗しました。" + procMessage;

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行キャンセルに失敗しました。" + procMessage;
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteSearch", LogType.Error, errMessage);
					}
				}
				else if (err.Code != CANWErrCode.Success)
				{
					// note : SearchHistory_TBLからレコード削除
					if (ClinicalSearchCoreLibs.DeleteSearchHistory(cmdWrite, searchHistoryId, out procMessage))
					{
						// Managerへの伝達のため
						err.Message = "検索実行が失敗しました。理由【" +  errMessage + "】";

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行が失敗しました。理由【" +  errMessage + "】";
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteSearch", LogType.Error, errMessage);
					}
					else
					{
						// Managerへの伝達のため
						err.Message = "検索実行が失敗しました。理由【" +  errMessage + "】";
						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行が失敗しました。理由【" +  errMessage + "】また、" 
							+ "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行キャンセルに失敗しました。" + procMessage;
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteSearch", LogType.Error, errMessage);
					}
				}
				else
				{
					// note : 成功時
					ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteSearch", LogType.Info, "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行が完了しました。");
				}

				// オブジェクトの初期化
                if (dr != null) { dr.Close(); }
                if (connWrite != null) { connWrite.Close(); }
				if (conn != null) conn.Close();

				m_canwErr = err;
			}
			return err;
        }

		/// <summary>
		/// スクリーニング検索
		/// </summary>
		/// <param name="sessionId">セッションID</param>
		/// <param name="analyzeConfigType">検索テンプレートタイプ</param>
		/// <param name="screeningSearchSettingComp">検索条件のバイナリデータ</param>
		/// <param name="analyzeConfigId">検索テンプレートID</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="userId">ユーザID</param>
		/// <param name="loginId">ログインID</param>
		/// <returns>Can用エラークラス</returns>
        private CANWErr ScreeningSearchProc(string sessionId, AnalyzeConfigTypeEnum analyzeConfigType, byte[] screeningSearchSettingComp, long analyzeConfigId, long searchHistoryId, long userId, string loginId)
        {
            CANWErr						err = new CANWErr(CANWErrCode.Success);
            SearchSetting30				searchSetting;
			List<SearchSetting30>		searchSettingList = new List<SearchSetting30>();
            Encoding					charSet = Encoding.GetEncoding("Shift_JIS");

            // note : 結果レコードの読み取り
			CanDbConnection				conn = new CanDbConnection(ClinicalSearchCoreLibs.GetConnectionStringCan());
            CanDbDataReader				dr = null;
            SqlManager					sqlManager;
            string						selectSql, insertSql;
            
			//全結果のDataSet
			DataSet						resultSet= new DataSet();

            // note : データセットフォーマット用
            string[]					columnNameList, displayNameList;
            
            // note : 結果バイナリの書き込み用
            CanDbConnection				connWrite = new CanDbConnection(ClinicalSearchCoreLibs.GetConnectionStringCan());
            CanDbCommand				cmdWrite = null;

			// note : ログの書き込み
			CanDbCommand				cmdLog = null;
			string						userName = "";
			string						targetDisplayName = "";

			ScreeningSearchSetting		screeningSearchSetting = null;
			int							searchOrder = 0;
			int							resultOrder = 0;
			string						procMessage = "";
			string						errMessage = "";
			CANWErrCode					procErrCode;
			string						searchJoinResultType = "A";

			try
			{
				conn.Open();
				connWrite.Open();
				sqlManager = new SqlManager();
				cmdWrite = new CanDbCommand("", connWrite, null);
				cmdLog = new CanDbCommand("", connWrite, null);
				this.ReadCommand = new CanDbCommand("", conn, null);

                string[] targetColumnTypes;
				string[] originalColumnTypes;
                NumericDateTimeFormat[] numericDateTimeFormats;

				// 進捗更新およびキャンセルチェック
				if (SetProgressRate(searchOrder, resultOrder, 0) && m_cancelRequest)
				{
					;	// キャンセル
				}
				else if (!ClinicalSearchCoreLibs.GetUserNameProc(this.ReadCommand, userId, this, out userName, out procMessage))
				{
					err.Code = CANWErrCode.System;
					errMessage = "ユーザー名の取得に失敗しました。" + procMessage;
				}
				else if (SetProgressRate(searchOrder, resultOrder, 1) && m_cancelRequest)
				{
					;	// キャンセル
				}
				// スクリーニング検索セットを解凍する
				else if (!ClinicalSearchCoreLibs.ExpandScreeningSearchSetting(screeningSearchSettingComp, out screeningSearchSetting, out procMessage))
				{
					errMessage = "SQLの生成に失敗しました。検索条件の解凍に失敗しました。" + procMessage;
					err.Code = CANWErrCode.InvalidVariable;
				}
				// 進捗更新およびキャンセルチェック
				else if (SetProgressRate(searchOrder, resultOrder, 2) && m_cancelRequest)
				{
					;	// キャンセル
				}
				// SearchHistory_TBLに追加する
				else if (!ClinicalSearchCoreLibs.AddSearchHistory(cmdWrite, searchHistoryId, screeningSearchSetting.TargetId, userId, analyzeConfigId, screeningSearchSettingComp, analyzeConfigType, loginId, out procMessage))
				{
					errMessage = "検索前処理に失敗しました。" + procMessage;
					err.Code = CANWErrCode.System;
				}
				// ScreeningSearchPart_TBLに追加する
				else if (!ClinicalSearchCoreLibs.AddScreeningSearchPart(cmdWrite, screeningSearchSetting, searchHistoryId, loginId, out errMessage))
				{
					errMessage = "検索前処理に失敗しました。" + procMessage;
					err.Code = CANWErrCode.System;
				}
				// 進捗更新およびキャンセルチェック
				else if (SetProgressRate(searchOrder, resultOrder, 3) && m_cancelRequest)
				{
					;	// キャンセル;
				}
				else
				{
					m_resultSearchOrder = screeningSearchSetting.SearchSettings.Length - 1;

					// 各SearchSetting単位
					for (searchOrder = 0; searchOrder < screeningSearchSetting.SearchSettings.Length; searchOrder++)
					{
                        this.CompletedPageCounts.Add(0);

						// 設定情報を格納(最小日時未満ものは置換しておく)
						searchSetting = ReplaceMinDateTime(screeningSearchSetting.SearchSettings[searchOrder]);
						searchSettingList.Add(searchSetting);
						// 進捗更新およびキャンセルチェック
						if (AddDataCnt(searchOrder, 0) && SetProgressRate(searchOrder, resultOrder, 4) && m_cancelRequest)
						{
							searchOrder++;
							break;	// キャンセル;
						}
						// 項目一覧を取得
						else if (!GetDisplayNameListProc(conn, searchSetting.TargetId, out targetDisplayName, out columnNameList,
							out displayNameList, out targetColumnTypes, out numericDateTimeFormats, out originalColumnTypes, out procMessage))
						{
							err.Code = CANWErrCode.System;
							errMessage = "検索ターゲットの項目一覧の取得に失敗しました。" + procMessage;
							searchOrder++;
							break;
						}
						else if (!sqlManager.GetSearchSql(conn, searchHistoryId, searchOrder, screeningSearchSetting.SearchSettings,
							columnNameList.ToList(), originalColumnTypes, out selectSql, out insertSql))
						{
							errMessage = "SQLの生成に失敗しました。検索条件が不正な可能性があります。";
							err.Code = CANWErrCode.InvalidVariable;
							searchOrder++;
							break;
						}
						// SQL文(select)のバイト数が制限値を超えているかを調べる
						else if (m_maxSqlLength > 0 && charSet.GetByteCount(selectSql) > m_maxSqlLength)
						{
							errMessage = "検索実行がキャンセルされました。設定値よりもSQLが長すぎます。[" + charSet.GetByteCount(selectSql).ToString() + "バイト/" + m_maxSqlLength.ToString() + "/バイト]";
							err.Code = CANWErrCode.TooLargeRequest;
							searchOrder++;
							break;
						}
						// SQL文(insert)のバイト数が制限値を超えているかを調べる
						else if (m_maxSqlLength > 0 && charSet.GetByteCount(insertSql) > m_maxSqlLength)
						{
							errMessage = "検索実行がキャンセルされました。設定値よりもSQLが長すぎます。[" + charSet.GetByteCount(insertSql).ToString() + "バイト/" + m_maxSqlLength.ToString() + "/バイト]";
							err.Code = CANWErrCode.TooLargeRequest;
							searchOrder++;
							break;
						}
						// 進捗更新およびキャンセルチェック
						else if (SetProgressRate(searchOrder, resultOrder, 5) && m_cancelRequest)
						{
							searchOrder++;
							break;	// キャンセル;
						}
						else
						{
                            DataTable screeningSearchResult;
                            // 途中結果
                            if (searchOrder < m_resultSearchOrder)
                            {
                                // 途中結果（全ての列）を取得してScreeningSearchPartResult_TBL
                                if (ReadDataAndInsertScreeningSearchPart(this.ReadCommand, cmdWrite, dr, selectSql,
									searchHistoryId, searchOrder, loginId, columnNameList, displayNameList, targetColumnTypes,
									numericDateTimeFormats, out screeningSearchResult, out procErrCode, out errMessage))
                                {
                                    //結果情報を格納
                                    screeningSearchResult.TableName = "T" + (searchOrder + 1).ToString();
                                    resultSet.Tables.Add(screeningSearchResult);
                                    try
                                    {
                                        // 途中結果（必要な列）を取得して次の処理用にSearchRelationCache_TBLへ追加する
                                        cmdWrite.Parameters.Clear();
                                        cmdWrite.CommandText = insertSql;
                                        cmdWrite.ExecuteNonQuery();
                                    }
                                    catch (CanDbException ex)
                                    {
                                        errMessage = ex.Message;
                                        err.Code = CANWErrCode.System;
                                    }
                                    finally
                                    {
                                        if (err.Code == CANWErrCode.Success)
                                        {
                                            // note : 成功
                                            ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, insertSql, m_ipAddress, loginId, LogType.Info, "", m_cancelRequest, false);
                                        }
                                        else
                                        {
                                            // note : insert時失敗
                                            ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, insertSql, m_ipAddress, loginId, LogType.Error, errMessage, m_cancelRequest, false);
                                        }
                                    }
                                }
                                else if (errMessage.Trim().Length == 0)
                                {
                                    // キャンセルされた
                                    ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, insertSql, m_ipAddress, loginId, LogType.Info, "検索実行処理が途中でキャンセルされました", m_cancelRequest, false);
                                    searchOrder++;
                                    break;
                                }
                                else
                                {
                                    ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, insertSql, m_ipAddress, loginId, LogType.Error, errMessage, m_cancelRequest, false);
                                    err.Code = procErrCode;
                                    searchOrder++;
                                    break;
                                }
                            }
                            // 最終結果を取得してSearchResultCache_TBLへ追加する
                            else if (ReadDataAndInsertSearchHistory(this.ReadCommand, cmdWrite, dr, selectSql,
								searchHistoryId, searchOrder, loginId, columnNameList, displayNameList, targetColumnTypes,
								numericDateTimeFormats, out screeningSearchResult, out procErrCode, out errMessage))
                            {
                                //結果情報を格納
                                screeningSearchResult.TableName = "T" + (searchOrder + 1).ToString();
                                resultSet.Tables.Add(screeningSearchResult);
                                // note : 成功
                                ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, insertSql, m_ipAddress, loginId, LogType.Info, "", m_cancelRequest, true);
                            }
                            else if (errMessage.Trim().Length == 0)
                            {
                                ;	// note : 処理中にキャンセルされた
                                ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, insertSql, m_ipAddress, loginId, LogType.Info, "検索実行処理が途中でキャンセルされました", m_cancelRequest, true);
                                searchOrder++;
                                break;
                            }
                            else
                            {
                                ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, searchSetting.TargetId, targetDisplayName, userId, userName, selectSql, insertSql, m_ipAddress, loginId, LogType.Error, errMessage, m_cancelRequest, true);
                                err.Code = procErrCode;
                                searchOrder++;
                                break;
                            }
                        }
					}
					//データテーブルの数が複数あり前処理が全て正常な場合のみ足し算の処理を開始する
					if (resultSet.Tables.Count > 1 && err.Code == CANWErrCode.Success)
					{
						// 進捗更新およびキャンセルチェック
						if (AddDataCnt(searchOrder, 0) && m_cancelRequest)
						{
							;
						}			
						// 外部キー制約はなく先に登録する必要はないが、通常の検索処理と合わせSearchJoinHistory_TBLを先に追加する
						else if (!ClinicalSearchCoreLibs.AddSearchJoinHistory(cmdWrite, screeningSearchSetting, searchHistoryId, searchJoinResultType, loginId, out errMessage))
						{
							errMessage = "足し算の検索前履歴登録に失敗しました。" + procMessage;
							err.Code = CANWErrCode.System;
						}
							
						//スクリーニング結果(足し算表示)
						DataSet additionDataSet = SqlManagerLibs.GetAdditionData(this.ReadCommand, resultSet, searchSettingList, this);
						if (additionDataSet != null && additionDataSet.Tables.Count > 0 && additionDataSet.Tables[0] != null)
						{
							// 最終結果を取得してSearchResultCache_TBLへ追加する
							if (JoinDataReadAndInsertSearchJoinHistory(cmdWrite, searchHistoryId, searchOrder, searchJoinResultType, loginId, additionDataSet, out procErrCode, out errMessage))
							{
								// note : 成功
								ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, 0, "足し算表示", userId, userName, "", "", m_ipAddress, loginId, LogType.Info, "", m_cancelRequest, true);
							}
							else if (errMessage.Trim().Length == 0)
							{
								// note : キャンセルされた
								ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, 0, "足し算表示", userId, userName, "", "", m_ipAddress, loginId, LogType.Info, "結合処理を途中でキャンセルしました", m_cancelRequest, true);
							}
							else
							{
								// note : 失敗
								ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, 0, "足し算表示", userId, userName, "", "", m_ipAddress, loginId, LogType.Error, errMessage, m_cancelRequest, true);
								err.Code = procErrCode;
							}
						}
					}
					else
					{
						// 結果テーブルが２つ以上なかった
						ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, searchOrder, 0, "足し算表示", userId, userName, "", "", m_ipAddress, loginId, LogType.Error, "結果が不足しているため結合処理ができませんでした", m_cancelRequest, true);
					}
                    ClinicalSearchCoreLibs.UpdateSearchHistoryTaskRunning(cmdWrite, searchHistoryId, TaskType.Normal);
				}
			}
			catch (CanDbException ex)
			{
				// note : DB2の場合に問い合わせたSQLのコストが高いためDBの処理がタイムアウトするとこの例外が投げられることがあるのでここで対応する
				if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "HY008"))
				{
					err.Code = CANWErrCode.Timeout;
                    errMessage = ex.Message;
				}
				// note : DB2の場合に問い合わせたSQLが長すぎるもしくは複雑すぎるとこの例外が投げられることがあるのでここで対応する
				else if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "54001"))
				{
					err.Code = CANWErrCode.TooLargeRequest;
                    errMessage = ex.Message;
				}
				else
				{
					err.Code = CANWErrCode.System;
                    errMessage = ex.Message;
				}
			}
			catch (Exception ex)
			{
				err.Code = CANWErrCode.System;
                errMessage = ex.Message;
			}
			finally
			{
				// note : 最後にLOG_TBLへ記載
				if (m_cancelRequest)
				{
					// note : 外部からのキャンセル依頼
					// note : SearchHistory_TBLからレコード削除
					if (ClinicalSearchCoreLibs.DeleteSearchHistory(cmdWrite, searchHistoryId, out procMessage))
					{
						// Managerへの伝達のためここでerr.Codeをキャンセルにする
						err.Code = CANWErrCode.CancelSearch;
						err.Message = "検索処理を途中でキャンセルしました。";

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行がキャンセルされました。";
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Info, errMessage);
					}
					// SearchJoinHistory_TBLからレコード削除
					else if (ClinicalSearchCoreLibs.DeleteSearchJoinHistory(cmdWrite, searchHistoryId, searchJoinResultType, out procMessage))
					{
						// Managerへの伝達のためここでerr.Codeをキャンセルにする
						err.Code = CANWErrCode.CancelSearch;
						err.Message = "結合結果(足し算表示)を途中でキャンセルしました。";

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の結合結果(足し算表示)がキャンセルされました。";
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Info, errMessage);
					}

					else
					{
						// Managerへの伝達のためここでerr.Codeをキャンセルにする
						err.Code = CANWErrCode.System;
						err.Message = "検索処理のキャンセルに失敗しました。" + procMessage;

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行キャンセルに失敗しました。" + procMessage;
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Error, errMessage);
					}
				}
				else if (err.Code != CANWErrCode.Success)
				{
					// note : SearchHistory_TBLからレコード削除
					if (ClinicalSearchCoreLibs.DeleteSearchHistory(cmdWrite, searchHistoryId, out procMessage))
					{
						// Managerへの伝達のため
						err.Message = "検索実行が失敗しました。理由【" +  errMessage + "】";

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行が失敗しました。理由【" +  errMessage + "】";
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Error, errMessage);
					}
					// SearchJoinHistory_TBLからレコード削除
					else if (ClinicalSearchCoreLibs.DeleteSearchJoinHistory(cmdWrite, searchHistoryId, searchJoinResultType, out procMessage))
					{
						// Managerへの伝達のため
						err.Message = "結合結果(足し算表示)が失敗しました。理由【" + errMessage + "】";

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の結合結果(足し算表示)が失敗しました。理由【" + errMessage + "】";
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Error, errMessage);
					}
					else
					{
						// Managerへの伝達のため
						err.Message = "検索実行が失敗しました。理由【" +  errMessage + "】";
						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行が失敗しました。理由【" +  errMessage + "】また、" 
							+ "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行キャンセルに失敗しました。" + procMessage;
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Error, errMessage);
					}
				}
				else
				{
					// note : 成功時
					ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Info, "検索履歴ID【" + searchHistoryId.ToString() + "】の検索実行が完了しました。");
				}

				// note : SearchRelation_TBLからレコード削除
			    if (!DeleteSearchRelationCacheProc(cmdWrite, searchHistoryId, out procMessage))
			    {
			        errMessage = "検索実行時の中間レコード削除に失敗しました。" + procMessage;
			        ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Error, errMessage);
			    }

				// オブジェクトの初期化
                if (dr != null) { dr.Close(); }
                if (connWrite != null) { connWrite.Close(); }
				if (conn != null) conn.Close();

				m_canwErr = err;
			}
			return err;
        }


        /// <summary>
        /// 検索設定の最小日時未満の日付を、扱える最少日時に置換
        /// </summary>
        /// <param name="searchSetting">検索設定</param>
        /// <returns>置換後の検索設定</returns>
        private SearchSetting30 ReplaceMinDateTime(SearchSetting30 searchSetting)
        {
            SearchSetting30 result = searchSetting;

            // Cache の場合のみ
            if (SqlLibs.GetDbType() == SqlLibs.DbTypeEnum.Cache)
            {
                // 条件が指定されている場合のみ置換処理
                if (result.Filters != null)
                {
                    result.Filters = ReplaceMinDateTime(result.Filters);
                }

                // 除外条件が指定されている場合のみ置換処理
                if (result.NotFilters != null)
                {
                    result.NotFilters = ReplaceMinDateTime(result.NotFilters);
                }
            }

            return result;
        }


        /// <summary>
        /// 検索条件の最小日時未満の日付を、扱える最少日時に置換
        /// </summary>
        /// <param name="searchFilters">検索条件一覧</param>
        /// <returns>置換後の検索条件一覧</returns>
        private SearchFilter[] ReplaceMinDateTime(SearchFilter[] searchFilters)
        {
            SearchFilter[] result = searchFilters;

            foreach (SearchFilter searchFilter in result)
            {
                foreach (SearchFilterDetail detail in searchFilter.FilterDetails)
                {
                    // 日付型以外は処理の必要なし
                    if (detail.DataType != DataTypeEnum.Date)
                    {
                        continue;
                    }

                    // 開始日時が扱うことのできる最小日時未満なら最小日時を設定する
                    if (((SearchFilterDetailDate)detail).SinceDate < this.MIN_DATE)
                    {
                        ((SearchFilterDetailDate)detail).SinceDate = this.MIN_DATE;
                    }

                    // 終了日時が扱うことのできる最小日時未満なら最小日時を設定する
                    if (((SearchFilterDetailDate)detail).ToDate < this.MIN_DATE)
                    {
                        ((SearchFilterDetailDate)detail).ToDate = this.MIN_DATE;
                    }
                }
            }

            return result;
        }


		/// <summary>
		/// 結合結果(掛け算表示)
		/// </summary>
		/// <param name="sessionId">セッションID</param>
		/// <param name="analyzeConfigType">検索テンプレートタイプ</param>
		/// <param name="screeningSearchSettingComp">検索条件のバイナリデータ</param>
		/// <param name="analyzeConfigId">検索テンプレートID</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="userId">ユーザID</param>
		/// <param name="loginId">ログインID</param>
		/// <returns>Can用エラークラス</returns>
		private CANWErr SearchJoinProc(string sessionId, AnalyzeConfigTypeEnum analyzeConfigType, byte[] screeningSearchSettingComp, long analyzeConfigId, long searchHistoryId, long userId, string loginId)
		{
			Encoding charSet = Encoding.GetEncoding("Shift_JIS");
			CANWErr err = new CANWErr(CANWErrCode.Success);
			string errMessage = "";

			// note : 結果レコードの読み取り
			CanDbConnection conn = new CanDbConnection(ClinicalSearchCoreLibs.GetConnectionStringCan());
			CanDbDataReader dr = null;
			SqlManager sqlManager;
			string selectSql;
			string orderSql;

			// note : 結果バイナリの書き込み用
			CanDbConnection connWrite = new CanDbConnection(ClinicalSearchCoreLibs.GetConnectionStringCan());
			CanDbCommand cmdWrite = null;

			// note : ログの書き込み
			CanDbCommand cmdLog = null;
			string userName = "";

			ScreeningSearchSetting screeningSearchSetting = null;
			int searchOrder = 0;
			int resultOrder = 0;
			string procMessage = "";
			string searchJoinResultType = "M";

			CANWErrCode procErrCode;

			SqlManagerSearchJoin sqlManagerSearchJoin = new SqlManagerSearchJoin();

			try
			{
				conn.Open();
				connWrite.Open();
				sqlManager = new SqlManager();
				cmdWrite = new CanDbCommand("", connWrite, null);
				cmdLog = new CanDbCommand("", connWrite, null);
				this.ReadCommand = new CanDbCommand("", conn, null);

				// 進捗更新およびキャンセルチェック
				if (SetProgressRate(searchOrder, resultOrder, 0) && m_cancelRequest)
				{
					;	// キャンセル
				}
				else if (!ClinicalSearchCoreLibs.GetUserNameProc(this.ReadCommand, userId, this, out userName, out procMessage))
				{
					err.Code = CANWErrCode.System;
					errMessage = "ユーザー名の取得に失敗しました。" + procMessage;
				}
				else if (SetProgressRate(searchOrder, resultOrder, 1) && m_cancelRequest)
				{
					;	// キャンセル
				}
				// スクリーニング検索セットを解凍する
				else if (!ClinicalSearchCoreLibs.ExpandScreeningSearchSetting(screeningSearchSettingComp, out screeningSearchSetting, out procMessage))
				{
					errMessage = "SQLの生成に失敗しました。検索条件の解凍に失敗しました。" + procMessage;
					err.Code = CANWErrCode.InvalidVariable;
				}
				// 外部キー制約はなく先に登録する必要はないが、通常の検索処理と合わせSearchJoinHistory_TBLを先に追加する
				else if (!ClinicalSearchCoreLibs.AddSearchJoinHistory(cmdWrite, screeningSearchSetting, searchHistoryId, searchJoinResultType, loginId, out errMessage))
				{
					errMessage = "検索前処理に失敗しました。" + procMessage;
					err.Code = CANWErrCode.System;
				}
				// 進捗更新およびキャンセルチェック
				else if (SetProgressRate(searchOrder, resultOrder, 3) && m_cancelRequest)
				{
					;	// キャンセル;
				}
				else
				{
					//表示項目情報の取得
					var targetDisplayNameList = new List<string>();
					var columnNameLists = new List<string[]>();
					var displayNameLists = new List<string[]>();
					var targetColumnTypeLists = new List<string[]>();
                    var numericDateTimeFormatLists = new List<NumericDateTimeFormat[]>();
					List<string[]> originalColumnTypeLists = new List<string[]>();

					for (int i = 0; i < screeningSearchSetting.SearchSettings.Length; i++)
					{
						SearchSetting30 searchSetting = screeningSearchSetting.SearchSettings[i];
						string targetDisplayName;
						string[] columnNameList;
						string[] displayNameList;
                        string[] targetColumnType;
						string[] originalColumnTypes;
                        NumericDateTimeFormat[] numericDateTimeFormat;

						if (!GetDisplayNameListProc(conn, searchSetting.TargetId, out targetDisplayName, out columnNameList, out displayNameList,
							out targetColumnType, out numericDateTimeFormat, out originalColumnTypes, out procMessage))
						{
							err.Code = CANWErrCode.System;
							errMessage = "検索ターゲットの項目一覧の取得に失敗しました。" + procMessage;
							break;
						}
						else
						{
							targetDisplayNameList.Add(targetDisplayName);

                            if (i < screeningSearchSetting.SearchSettings.Length - 1)
                            {
                                // DBの予約語「SELECT」を境界線項目とする
                                var columnNames = new List<string>(columnNameList);
                                columnNames.Add("SELECT");
                                var displayNames = new List<string>(displayNameList);
                                displayNames.Add("SELECT" + (i + 1).ToString());
								var targetColumnTypes = new List<string>(targetColumnType);
								targetColumnTypes.Add("STRING");
								var numericDateTimeFormats = new List<NumericDateTimeFormat>();
								numericDateTimeFormats.AddRange(numericDateTimeFormat);
								numericDateTimeFormats.Add(NumericDateTimeFormat.None);

                                columnNameLists.Add(columnNames.ToArray());
                                displayNameLists.Add(displayNames.ToArray());
								targetColumnTypeLists.Add(targetColumnTypes.ToArray());
								numericDateTimeFormatLists.Add(numericDateTimeFormats.ToArray());
                            }
                            else
                            {
                                columnNameLists.Add(columnNameList);
                                displayNameLists.Add(displayNameList);
								targetColumnTypeLists.Add(targetColumnType);
                                numericDateTimeFormatLists.Add(numericDateTimeFormat);
                            }
                            originalColumnTypeLists.Add(originalColumnTypes);
						}
					}
					// 最終結果の順序を設定しておく
					m_resultSearchOrder = searchOrder;

					if (AddDataCnt(searchOrder, 0) & SetProgressRate(searchOrder, resultOrder, 4) && m_cancelRequest)
					{
						;	// キャンセル;
					}
					else if (!sqlManagerSearchJoin.GetSearchJoinSql(conn, searchHistoryId, searchOrder,
						screeningSearchSetting.SearchSettings, columnNameLists, originalColumnTypeLists , out selectSql, out orderSql))
					{
						errMessage = "SQLの生成に失敗しました。検索条件が不正な可能性があります。";
						err.Code = CANWErrCode.InvalidVariable;
					}
					// SQL文(select)のバイト数が制限値を超えているかを調べる
					else if (m_maxSqlLength > 0 && charSet.GetByteCount(selectSql) > m_maxSqlLength)
					{
						errMessage = "検索実行がキャンセルされました。設定値よりもSQLが長すぎます。[" + charSet.GetByteCount(selectSql).ToString() + "バイト/" + m_maxSqlLength.ToString() + "/バイト]";
						err.Code = CANWErrCode.TooLargeRequest;
					}
					// 進捗更新およびキャンセルチェック
					else if (SetProgressRate(searchOrder, resultOrder, 5) && m_cancelRequest)
					{
						;	// キャンセル;
					}
					else
					{
                        // 最終結果を取得してSearchResultCache_TBLへ追加する
						if (MultiDataCreateAndInsertSearchJoinHistory(this.ReadCommand, cmdWrite, dr, selectSql,
							orderSql, searchHistoryId, searchOrder, searchJoinResultType, loginId, columnNameLists,
							displayNameLists, targetColumnTypeLists, numericDateTimeFormatLists, out procErrCode, out errMessage))
                        {
                            // note : 成功
                            ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, -1, 0, "掛け算表示", userId, userName, selectSql, "", m_ipAddress, loginId, LogType.Info, "", m_cancelRequest, true);
                        }
                        else if (errMessage.Trim().Length == 0)
                        {
                            // note : キャンセルされた
                            ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, -1, 0, "掛け算表示", userId, userName, selectSql, "", m_ipAddress, loginId, LogType.Info, "結合処理を途中でキャンセルしました", m_cancelRequest, true);
                        }
                        else
                        {
                            // note : 失敗
                            ClinicalSearchCoreLibs.AddSearchLogProc(cmdLog, searchHistoryId, -1, 0, "掛け算表示", userId, userName, selectSql, "", m_ipAddress, loginId, LogType.Error, errMessage, m_cancelRequest, true);
                        }
					}
                    ClinicalSearchCoreLibs.UpdateSearchHistoryTaskRunning(cmdWrite, searchHistoryId, TaskType.Multi);
				}
			}
			catch (CanDbException ex)
			{
				// note : DB2の場合に問い合わせたSQLのコストが高いためDBの処理がタイムアウトするとこの例外が投げられることがあるのでここで対応する
				if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "HY008"))
				{
					err.Code = CANWErrCode.Timeout;
					errMessage = ex.Message;
				}
				// note : DB2の場合に問い合わせたSQLが長すぎるもしくは複雑すぎるとこの例外が投げられることがあるのでここで対応する
				else if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "54001"))
				{
					err.Code = CANWErrCode.TooLargeRequest;
					errMessage = ex.Message;
				}
				else
				{
					err.Code = CANWErrCode.System;
					errMessage = ex.Message;
				}
			}
			catch (Exception ex)
			{
				err.Code = CANWErrCode.System;
				errMessage = ex.Message;
			}
			finally
			{
				// note : 最後にLOG_TBLへ記載
				if (m_cancelRequest)
				{
					// note : 外部からのキャンセル依頼
					// note : SearchJoinHistory_TBLからレコード削除
					if (ClinicalSearchCoreLibs.DeleteSearchJoinHistory(cmdWrite, searchHistoryId, searchJoinResultType, out procMessage))
					{
						// Managerへの伝達のためここでerr.Codeをキャンセルにする
						err.Code = CANWErrCode.CancelSearch;
						err.Message = "結合結果(掛け算表示)を途中でキャンセルしました。";

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の結合結果(掛け算表示)がキャンセルされました。";
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Info, errMessage);
					}
					else
					{
						// Managerへの伝達のためここでerr.Codeをキャンセルにする
						err.Code = CANWErrCode.System;
						err.Message = "結合結果(掛け算表示)のキャンセルに失敗しました。" + procMessage;

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の結合結果(掛け算表示)キャンセルに失敗しました。" + procMessage;
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Error, errMessage);
					}
				}
				else if (err.Code != CANWErrCode.Success)
				{
					// note : SearchJoinHistory_TBLからレコード削除
					if (ClinicalSearchCoreLibs.DeleteSearchJoinHistory(cmdWrite, searchHistoryId, searchJoinResultType, out procMessage))
					{
						// Managerへの伝達のため
						err.Message = "結合結果(掛け算表示)が失敗しました。理由【" + errMessage + "】";

						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の結合結果(掛け算表示)が失敗しました。理由【" + errMessage + "】";
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Error, errMessage);
					}
					else
					{
						// Managerへの伝達のため
						err.Message = "結合結果(掛け算表示)が失敗しました。理由【" + errMessage + "】";
						// note : Log_TBLへ記載
						errMessage = "検索履歴ID【" + searchHistoryId.ToString() + "】の結合結果(掛け算表示)が失敗しました。理由【" + errMessage + "】また、"
							+ "検索履歴ID【" + searchHistoryId.ToString() + "】の結合結果(掛け算表示)キャンセルに失敗しました。" + procMessage;
						ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Error, errMessage);
					}
				}
				else
				{
					// note : 成功時
					ClinicalSearchCoreLibs.WriteLog(cmdLog, m_ipAddress, loginId, "ExecuteScreeningSearch", LogType.Info, "検索履歴ID【" + searchHistoryId.ToString() + "】の結合結果(掛け算表示)が完了しました。");
				}

				if (dr != null)
				{
					dr.Close();
				}
				if (connWrite != null)
				{
					connWrite.Close();
				}
				if (conn != null)
				{
					conn.Close();
				}

				m_canwErr = err;
			}
			return err;
		}



		/// <summary>
		/// 結合結果(DataSet)をSearchJoinResultCache_TBLへ追加する関数
		/// </summary>
		/// <param name="cmdWrite">書き込み用のDBコネクション</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="searchJoinResultType">結合種別</param>
		/// <param name="loginId">ログインID</param>
		/// <param name="errCode">エラーコード</param>
		/// <param name="errMessage">エラーメッセージ</param>
		/// <returns>正常終了フラグ</returns>
		private bool JoinDataReadAndInsertSearchJoinHistory(CanDbCommand cmdWrite, long searchHistoryId, int searchOrder, string searchJoinResultType, string loginId, DataSet searchResult, out CANWErrCode errCode, out string errMessage)
		{
			int joinResultOrder = 0;
			int rowCount = 0;
			bool bReturn = true;
			string procMessage = "";
			DataSet searchResultBuf = new DataSet();

			errCode = CANWErrCode.Success;
			errMessage = "";

			// データセットをフォーマットする
			DataTable dataTableBuf = new DataTable();
			dataTableBuf = searchResult.Tables[0].Clone();
			searchResultBuf.Tables.Add(dataTableBuf);

			try
			{
				// 結果が0件の場合
				if (searchResult.Tables[0].Rows.Count == 0)
				{
					// 進捗更新およびキャンセルチェック
					if (SetProgressRate(searchOrder, joinResultOrder, 7) && m_cancelRequest)
					{
						bReturn = false;	// キャンセル;
					}
					else
					{
						joinResultOrder++;
						//結果データを圧縮してDBへ登録
						if (!InsertSearchJoinHistory
							(cmdWrite, searchHistoryId, searchOrder, joinResultOrder, searchJoinResultType, loginId, searchResultBuf, 0, out errCode, out errMessage))
						{
							bReturn = false;
						}
					}
				}
				else
				{
					// データ読み込みループ開始
					while (!m_cancelRequest && bReturn && searchResult.Tables[0].Rows.Count != rowCount)
					{
						// 読み込みカウンタをインクリメント
						m_dataCntList[searchOrder]++;

						if (m_dataCntList[searchOrder] > m_maxDataCnt)
						{
							errCode = CANWErrCode.TooManyDataCnt;
							errMessage = "該当する件数が多すぎます。" + m_maxDataCnt.ToString() + " 件以下になるように、検索条件の絞り込みを行ってください。";
							bReturn = false;
							break;
						}
						else
						{
							// データセットに１レコード追加する
							DataRow row = searchResultBuf.Tables[0].NewRow();
							row.ItemArray = searchResult.Tables[0].Rows[rowCount].ItemArray;
							searchResultBuf.Tables[0].Rows.Add(row);
							rowCount++;

							// 1ページの終端なので、とりためたデータをDBに書き込む
							if (m_dataCntList[searchOrder] % m_divisionRange == 0)
							{
								joinResultOrder++;
								//結果データを圧縮してDBへ登録
								if (!InsertSearchJoinHistory
                                    (cmdWrite, searchHistoryId, searchOrder, joinResultOrder, searchJoinResultType, loginId, searchResultBuf, this.m_dataCntList[searchOrder], out errCode, out errMessage))
								{
									bReturn = false;
									break;
								}

								//登録した結果をクリアしてメモリを解放します
								searchResultBuf.Tables[0].Rows.Clear();
								System.GC.Collect(); 
							}
						}
					}	// note : データ読み込みループ終端

					// 進捗更新およびキャンセルチェック
					if (SetProgressRate(searchOrder, joinResultOrder, 7) && m_cancelRequest)
					{
						bReturn = false; // キャンセル;
					}
					else if (bReturn)
					{
						// ループ終了時にsearchResultBuff.Tables[0]にデータが1件でもあれば、ここで登録する
						if (searchResultBuf.Tables[0].Rows.Count > 0)
						{
							joinResultOrder++;

							//結果データを圧縮してDBへ登録
							if (!InsertSearchJoinHistory
                                (cmdWrite, searchHistoryId, searchOrder, joinResultOrder, searchJoinResultType, loginId, searchResultBuf, this.m_dataCntList[searchOrder], out errCode, out errMessage))
							{
								bReturn = false;
							}
							//登録した結果をクリアしてメモリを解放します
							searchResultBuf.Tables[0].Rows.Clear();
							System.GC.Collect();
						}
					}
				}

				// 最後に検索履歴のデータ件数と履歴分割数を更新する
				if (bReturn && !m_cancelRequest)
				{
//					// 検索履歴を更新
//					if (!ClinicalSearchCoreLibs.UpdateSearchJoinHistoryDataCnt(cmdWrite, searchHistoryId, searchJoinResultType, m_dataCntList[searchOrder], joinResultOrder, out procMessage))
//					{
//						bReturn = false;
//						errMessage = procMessage;
//					}
//					else
//					{
						// 成功
						m_successSearchOrders.Add(searchOrder);
//					}
				}
			}
			catch (Exception ex)
			{
				bReturn = false;
				errCode = CANWErrCode.System;
				errMessage = ex.Message;
			}
			finally
			{
				//登録した結果をクリアしてメモリを解放します
				searchResult.Tables[0].Rows.Clear();
				System.GC.Collect();
			}


			return bReturn;
		}


#if UNITTEST
        /// <summary>
        /// テストメソッド用 SQL フィールド
        /// </summary>
        private string testSql;
#endif

        /// <summary>
		/// 結合結果(掛け算)のDataSetを作成しSearchJoinResultCache_TBLへ追加する関数
		/// </summary>
		/// <param name="cmdRead">読み込み用のDBコネクション</param>
		/// <param name="cmdWrite">書き込み用のDBコネクション</param>
		/// <param name="dr">データリーダー</param>
		/// <param name="selectSql">セレクトSQL</param>
		/// <param name="orderSql">orderby句のSQL</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="searchJoinResultType">結合種別</param>
		/// <param name="loginId">ログインID</param>
		/// <param name="columnNameList">カラム項目一覧</param>
		/// <param name="displayNameList">表示名称一覧</param>
        /// <param name="targetColumnTypes">ターゲット項目型一覧</param>
        /// <param name="numericDateTimeFormats">数値型日付フォーマット一覧</param>
		/// <param name="errCode">エラーコード</param>
		/// <param name="errMessage">エラーメッセージ</param>
		/// <returns>正常終了フラグ</returns>
		private bool MultiDataCreateAndInsertSearchJoinHistory(CanDbCommand cmdRead,
                                                                    CanDbCommand cmdWrite,
                                                                    CanDbDataReader dr,
                                                                    string selectSql,
                                                                    string orderSql,
                                                                    long searchHistoryId,
                                                                    int searchOrder,
                                                                    string searchJoinResultType,
                                                                    string loginId,
                                                                    List<string[]> columnNameLists,
                                                                    List<string[]> displayNameLists,
                                                                    List<string[]> targetColumnTypeLists,
                                                                    List<NumericDateTimeFormat[]> numericDateTimeFormatLists,
                                                                    out CANWErrCode errCode,
                                                                    out string errMessage)
		{

			bool bReturn = true;
			DataSet searchResult = new DataSet();
			string dataCount = "";

			//データテーブル用のカラムリストを作成
			List<string> columnNameList = new List<string>();
			List<string> displayNameList = new List<string>();
            var targetColumnTypes = new List<string>();
            var numericDateTimeFormats = new List<NumericDateTimeFormat>();

			errCode = CANWErrCode.Success;
			errMessage = "";

			try
			{
				// 結果を取得する
				if (dr != null) { dr.Close(); }

				string countSql = "select count(*) AS RecordCount from (" + selectSql + ") DataCount";
				
				//先にデータの件数をチェック
				cmdRead.Parameters.Clear();
				cmdRead.CommandText = countSql;

#if UNITTEST
                // テスト用 SQL を実行する
                cmdRead.CommandText = testSql;
#endif

                dr = SqlLibs.ExecuteReader(cmdRead, this);

                // SQL 実行がキャンセルされた
                if (this.CancelRequest)
                {
                    bReturn = false;
#if UNITTEST
                    errMessage = "検索処理(件数取得)を途中でキャンセルしました";
#endif
                }
                // SQL 実行が完了
                else
                {
                    if (dr.HasRows == true)
                    {
                        dr.Read();
                        dataCount = dr["RecordCount"].ToString();
                    }
                    if (dr != null) { dr.Close(); }

					for (int i = 0; i < columnNameLists.Count; i++)
					{
						columnNameList.AddRange(columnNameLists[i].Select(s => s + "_T" + (i + 1).ToString()).ToArray());
						displayNameList.AddRange(displayNameLists[i]);
						targetColumnTypes.AddRange(targetColumnTypeLists[i]);
						numericDateTimeFormats.AddRange(numericDateTimeFormatLists[i]);
					}

					// 最大件数以上又は0件であれば、レコード数が0になる条件を付与しデータテーブルを作成
					if (int.Parse(dataCount) > m_maxDataCnt || int.Parse(dataCount) == 0)
					{

						bReturn = CreateEmptyJoinData(cmdRead,
															cmdWrite,
															dr,
															selectSql,
															searchHistoryId,
															searchOrder,
															searchJoinResultType,
															loginId,
															columnNameList,
															displayNameList,
															targetColumnTypes,
															numericDateTimeFormats,
															dataCount,
															out errCode,
															out errMessage);
					}
					// 最大件数以下であればorderbyを指定してデータテーブルを作成
					else
					{
						bReturn = CreateJoinData(cmdRead,
													cmdWrite,
													dr,
													selectSql,
													orderSql,
													searchHistoryId,
													searchOrder,
													searchJoinResultType,
													loginId,
													columnNameList,
													displayNameList,
													targetColumnTypes,
													numericDateTimeFormats,
													out errCode,
													out errMessage);
					}
				}
			}
			catch (CanDbException ex)
			{
                //エクセプションが発生した場合でもクライアントで自然な動きになるために
                //レコード数が0になる条件を付与しデータテーブルを作成
                searchResult = CreateZeroCountDataSet(cmdRead, dr, selectSql, columnNameList.ToArray(), displayNameList.ToArray(), targetColumnTypes.ToArray(), numericDateTimeFormats.ToArray());

				// この時点でキャンセルされていない場合のみ結果を書き込む
				if (this.CancelRequest == false)
				{
					//作成されたDataSetを書き込みする
					JoinDataReadAndInsertSearchJoinHistory(cmdWrite, searchHistoryId, searchOrder, searchJoinResultType, loginId, searchResult, 
                        out errCode, out errMessage);
				}

                bReturn = false;

				// note : DB2の場合に問い合わせたSQLのコストが高いためDBの処理がタイムアウトするとこの例外が投げられることがあるのでここで対応する
				if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "HY008"))
				{
					errCode = CANWErrCode.Timeout;
					errMessage = ex.Message;
				}
				// note : DB2の場合に問い合わせたSQLが長すぎるもしくは複雑すぎるとこの例外が投げられることがあるのでここで対応する
				else if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "54001"))
				{
					errCode = CANWErrCode.TooLargeRequest;
					errMessage = ex.Message;
				}
				else
				{
					errCode = CANWErrCode.System;
					errMessage = ex.Message;
				}
			}
			finally
			{
				if (dr != null) { dr.Close(); }
				System.GC.Collect(); 
			}

			return bReturn;
		}

		/// <summary>
		/// 空の掛け算結果を作成してレコード登録
		/// </summary>
		/// <param name="cmdRead">読み込み用のDBコネクション</param>
		/// <param name="cmdWrite">書き込み用のDBコネクション</param>
		/// <param name="dr">データリーダー</param>
		/// <param name="selectSql">セレクトSQL</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="searchJoinResultType">結合種別</param>
		/// <param name="loginId">ログインID</param>
		/// <param name="columnNames">カラム項目一覧</param>
		/// <param name="displayNames">表示名称一覧</param>
		/// <param name="targetColumnTypes">ターゲット項目型一覧</param>
		/// <param name="numericDateTimeFormats">数値型日付フォーマット一覧</param>
		/// <param name="dataCount">データ件数</param>
		/// <param name="errCode">エラーコード</param>
		/// <param name="errMessage">エラーメッセージ</param>
		/// <returns>TRUE:正常終了, FALSE:異常終了</returns>
		private bool CreateEmptyJoinData(CanDbCommand cmdRead,
											CanDbCommand cmdWrite,
											CanDbDataReader dr,
											string selectSql,
											long searchHistoryId,
											int searchOrder,
											string searchJoinResultType,
											string loginId,
											List<string> columnNames,
											List<string> displayNames,
											List<string> targetColumnTypes,
											List<NumericDateTimeFormat> numericDateTimeFormats,
											string dataCount,
											out CANWErrCode errCode,
											out string errMessage)
		{
			bool bReturn = true;

			errCode = CANWErrCode.Success;
			errMessage = string.Empty;

			//最大件数以上又は0件であれば、レコード数が0になる条件を付与しデータテーブルを作成
			DataSet searchResult = CreateZeroCountDataSet(cmdRead, dr, selectSql, columnNames.ToArray(),
				displayNames.ToArray(), targetColumnTypes.ToArray(), numericDateTimeFormats.ToArray());

			// キャンセルされている
			if (this.CancelRequest)
			{
				bReturn = false;
			}
			else
			{
				//作成されたDataSetを書き込みする
				if (!JoinDataReadAndInsertSearchJoinHistory(cmdWrite, searchHistoryId, searchOrder,
					searchJoinResultType, loginId, searchResult, out errCode, out errMessage))
				{
					bReturn = false;
				}

				//最大件数以上の場合はログを設定
				//JoinDataReadAndInsertSearchJoinHistory内でも同様のチェックを行っているが掛け算の場合は
				//事前に件数をチェックしDataTableを0件で構築しているためログの重複にはなりません。
				if (bReturn && int.Parse(dataCount) > m_maxDataCnt)
				{
					errCode = CANWErrCode.TooManyDataCnt;
					errMessage = "該当する件数が多すぎます。" + m_maxDataCnt.ToString() + " 件以下になるように、検索条件の絞り込みを行ってください。";
					bReturn = false;
				}
			}

			return bReturn;
		}

		/// <summary>
		/// データありの掛け算結果を作成してレコード登録
		/// </summary>
		/// <param name="cmdRead">読み込み用のDBコネクション</param>
		/// <param name="cmdWrite">書き込み用のDBコネクション</param>
		/// <param name="dr">データリーダー</param>
		/// <param name="selectSql">セレクトSQL</param>
		/// <param name="orderSql">orderby句のSQL</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="searchJoinResultType">結合種別</param>
		/// <param name="loginId">ログインID</param>
		/// <param name="columnNames">カラム項目一覧</param>
		/// <param name="displayNames">表示名称一覧</param>
		/// <param name="targetColumnTypes">ターゲット項目型一覧</param>
		/// <param name="numericDateTimeFormats">数値型日付フォーマット一覧</param>
		/// <param name="errCode">エラーコード</param>
		/// <param name="errMessage">エラーメッセージ</param>
		/// <returns>TRUE:正常終了, FALSE:異常終了</returns>
		private bool CreateJoinData(CanDbCommand cmdRead,
										CanDbCommand cmdWrite,
										CanDbDataReader dr,
										string selectSql,
										string orderSql,
										long searchHistoryId,
										int searchOrder,
										string searchJoinResultType,
										string loginId,
										List<string> columnNames,
										List<string> displayNames,
										List<string> targetColumnTypes,
										List<NumericDateTimeFormat> numericDateTimeFormats,
										out CANWErrCode errCode,
										out string errMessage)
		{
			bool bReturn = true;

			errCode = CANWErrCode.Success;
			errMessage = string.Empty;


			// 最大件数以下であればorderbyを指定してデータテーブルをを作成
			cmdRead.Parameters.Clear();
			cmdRead.CommandText = selectSql;
			System.Diagnostics.Debug.WriteLine(cmdRead.CommandText);
			dr = SqlLibs.ExecuteReader(cmdRead, this);

			// SQL 実行がキャンセルされた
			if (this.CancelRequest)
			{
				bReturn = false;
#if UNITTEST
                errMessage = "検索処理(実レコード取得)を途中でキャンセルしました";
#endif
			}
			// SQL 実行が完了
			else
			{

				DataSet searchResult = new DataSet();
				DataSet searchResultBuff = null;

				m_dataCntList[searchOrder] = 0;

				// データセットをフォーマットする
				searchResult.Tables.Add();
				CreateSearchResultBuff(dr, columnNames.ToArray(), displayNames.ToArray(),
					targetColumnTypes.ToArray(), numericDateTimeFormats.ToArray(), out searchResultBuff);
				searchResult.Tables[0].Merge(searchResultBuff.Tables[0]);

				// データ読み込みループ開始
				while (!m_cancelRequest && bReturn && dr.Read())
				{
					// データセットにレコード追加する
					AddDataRow(dr, searchResult.Tables[0], columnNames.ToArray(), numericDateTimeFormats.ToArray());
				}
				//drは不要のためクローズ
				if (dr != null) { dr.Close(); }

				//DataViewに変換してソート処理
                using (var dataView = new DataView(searchResult.Tables[0].Copy()))
                {
                    dataView.Sort = orderSql;

                    // ソート後のデータを再度DataTableへセット
                    searchResult.Tables[0].Clear();
                    foreach (DataRowView dataRowView in dataView)
                    {
                        searchResult.Tables[0].ImportRow(dataRowView.Row);
                    }
                }

				//作成されたDataSetを書き込みする
				if (!JoinDataReadAndInsertSearchJoinHistory(cmdWrite, searchHistoryId, searchOrder,
					searchJoinResultType, loginId, searchResult, out errCode, out errMessage))
				{
					bReturn = false;
				}
			}

			return bReturn;
		}

		/// <summary>
		/// 掛け算の結果が① 0 件か②制限オーバーか③CanDbException が発生した時でも画面では空データを表示するため
		/// 空の DataSet を DB に入れるために 0 件の DataTable を作成して DataSet を作成する
		/// </summary>
		/// <param name="cmdRead">読み込み用のDBコマンド</param>
		/// <param name="dr">データリーダー</param>
		/// <param name="selectSql">セレクトSQL</param>
		/// <param name="columnNameList">カラム名一覧</param>
        /// <param name="displayNameList">表示名一覧</param>
        /// <param name="targetColumnTypes">ターゲット項目型一覧</param>
        /// <param name="numericDateTimeFormats">数値型日付フォーマット一覧</param>
        /// <returns>0 件の DataTable を持つ DataSet</returns>
		private DataSet CreateZeroCountDataSet(CanDbCommand cmdRead,
                                                    CanDbDataReader dr,
                                                    string selectSql,
                                                    string[] columnNameList,
                                                    string[] displayNameList,
                                                    string[] targetColumnTypes,
                                                    NumericDateTimeFormat[] numericDateTimeFormats)
        {
            DataSet searchResult = new DataSet();
            DataSet searchResultBuff = null;

            //最大件数以上又は0件であれば、レコード数が0になる条件を付与しデータテーブルを作成
            cmdRead.Parameters.Clear();
            cmdRead.CommandText = selectSql + " WHERE 1=0";
            System.Diagnostics.Debug.WriteLine(cmdRead.CommandText);

#if UNITTEST
            // テスト用 SQL を実行
            cmdRead.CommandText = testSql;
#endif

            dr = SqlLibs.ExecuteReader(cmdRead, this);

#if UNITTEST
            // SQL がキャンセルされた
            if (this.CancelRequest)
            {
                searchResult.DataSetName = "検索処理を途中でキャンセルしました";
            }
#endif
			// キャンセルされていない場合のみフォーマット
			// (キャンセルされている場合は、このメソッドの呼び元の直後でもキャンセル判定を行っているため戻り値に左右されない)
			if (this.CancelRequest == false)
			{
				// データセットをフォーマットする
				searchResult.Tables.Add();
				CreateSearchResultBuff(dr, columnNameList.ToArray(), displayNameList.ToArray(), targetColumnTypes, numericDateTimeFormats, 
                    out searchResultBuff);
				searchResult.Tables[0].Merge(searchResultBuff.Tables[0]);
			}

            return searchResult;
        }

        /// <summary>
		/// 結合結果のDataSetをSearchJoinResultCache_TBLへ追加する関数
		/// </summary>
		/// <param name="cmdRead">読み込み用のDBコネクション</param>
		/// <param name="cmdWrite">書き込み用のDBコネクション</param>
		/// <param name="dr">データリーダー</param>
		/// <param name="selectSql">セレクトSQL</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="loginId">ログインID</param>
		/// <param name="columnNameList">カラム項目一覧</param>
		/// <param name="displayNameList">表示名称一覧</param>
		/// <param name="errCode">エラーコード</param>
		/// <param name="errMessage">エラーメッセージ</param>
		/// <returns>正常終了フラグ</returns>
		private bool InsertSearchJoinHistory(CanDbCommand cmdWrite, long searchHistoryId, int searchOrder, int joinResultOrder, string searchJoinResultType, string loginId, DataSet searchResultBuf, int dataCount, out CANWErrCode errCode, out string errMessage)
		{

			bool bReturn = true;
			byte[] searchJoinResultComp = null;
			string procMessage = "";

			errCode = CANWErrCode.Success;
			errMessage = "";

			try
			{
				if (CompressDataSet(searchResultBuf, out searchJoinResultComp))
				{
					// 進捗更新およびキャンセルチェック
					if (SetProgressRate(searchOrder, joinResultOrder, 6) && m_cancelRequest)
					{
						bReturn = false;	// キャンセル
					}
					else if (ClinicalSearchCoreLibs.AddSearchJoinResultCache(cmdWrite, searchHistoryId, joinResultOrder, searchJoinResultType, searchJoinResultComp, loginId, out procMessage))
					{
                        var updateResult = ClinicalSearchCoreLibs.UpdateSearchJoinHistory(cmdWrite, searchHistoryId, searchJoinResultType, dataCount, joinResultOrder);
                        if (updateResult.Code == CANWErrCode.Success)
                        {
//                            this.CompletedPageCounts[searchOrder]++;
                        }
                        else
                        {
                            errMessage = updateResult.Message;
                            bReturn = false;
                        }
					}
					else
					{
						errMessage = "検索結果キャッシュの追加に失敗しました。" + procMessage;
						bReturn = false;
					}
				}
				else
				{
					errMessage = "検索結果のデータ圧縮に失敗しました。";
					bReturn = false;
				}
			}
			catch (CanDbException ex)
			{
				bReturn = false;
				errCode = CANWErrCode.System;
				errMessage = ex.Message;
			}
			finally
			{
				;
			}

			return bReturn;
		}


		/// <summary>
		/// select文の結果を読み取りながら、取得結果をSearchHistory_TBLへ追加する関数
		/// </summary>
		/// <param name="cmdRead">読み込み用のDBコネクション</param>
		/// <param name="cmdWrite">書き込み用のDBコネクション</param>
		/// <param name="dr">データリーダー</param>
		/// <param name="selectSql">セレクトSQL</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="loginId">ログインID</param>
		/// <param name="columnNameList">カラム項目一覧</param>
        /// <param name="displayNameList">表示名称一覧</param>
        /// <param name="targetColumnTypes">ターゲット項目型一覧</param>
        /// <param name="numericDateTimeFormats">数値型日付フォーマット一覧</param>
		/// <param name="errCode">エラーコード</param>
		/// <param name="errMessage">エラーメッセージ</param>
		/// <returns>正常終了フラグ</returns>
        private bool ReadDataAndInsertSearchHistory(CanDbCommand cmdRead,
                                                        CanDbCommand cmdWrite,
                                                        CanDbDataReader dr,
                                                        string selectSql,
                                                        long searchHistoryId,
                                                        int searchOrder,
                                                        string loginId,
                                                        string[] columnNameList,
                                                        string[] displayNameList,
                                                        string[] targetColumnTypes,
                                                        NumericDateTimeFormat[] numericDateTimeFormats,
                                                        out DataTable screeningSearchResult,
                                                        out CANWErrCode errCode,
                                                        out string errMessage)
		{

			bool		bReturn = true;
			DataSet		searchResultBuf = null;
			byte[]		searchResultComp = null;
			int			resultOrder = 0;
			string		procMessage = "";

			errCode = CANWErrCode.Success;
			errMessage = "";
			screeningSearchResult = new DataTable();

			try
			{
				// 結果を取得する
				if (dr != null) { dr.Close(); }
				cmdRead.Parameters.Clear();
				cmdRead.CommandText = selectSql;
				dr = SqlLibs.ExecuteReader(cmdRead, this);

				// SQL 実行がキャンセルされた
				if (this.CancelRequest)
				{
					bReturn = false;
#if UNITTEST
                    errMessage = "検索処理を途中でキャンセルしました";
#endif
				}
				// SQL 実行が完了
				else
				{
					m_dataCntList[searchOrder] = 0;

					// 結果が0件の場合
					if (dr.HasRows == false)
					{
						// データセットをフォーマットする
						CreateSearchResultBuff(dr, columnNameList, displayNameList, targetColumnTypes, numericDateTimeFormats, out searchResultBuf);
						// DataReaderクリア
						if (dr != null) { dr.Close(); }

						// 進捗更新およびキャンセルチェック
						if (SetProgressRate(searchOrder, resultOrder, 6) && m_cancelRequest)
						{
							bReturn = false;    // キャンセル;
						}
						else
						{
							resultOrder++;

							if (CompressDataSet(searchResultBuf, out searchResultComp))
							{
								// 進捗更新およびキャンセルチェック
								if (SetProgressRate(searchOrder, resultOrder, 6) && m_cancelRequest)
								{
									bReturn = false;    // キャンセル
								}
								else if (ClinicalSearchCoreLibs.AddSearchResultCache(cmdWrite, searchHistoryId, resultOrder, searchResultComp, loginId, out procMessage))
								{
									var updateResult = ClinicalSearchCoreLibs.UpdateSearchHistory(cmdWrite, searchHistoryId, this.m_dataCntList[searchOrder], resultOrder);
									if (updateResult.Code == CANWErrCode.Success)
									{
										//上位に結果をマージして戻す
										screeningSearchResult.Merge(searchResultBuf.Tables[0]);
										// 作業用のデータセットのレコードを削除
										searchResultBuf.Tables[0].Rows.Clear();

										// 完了ページ数を更新
										this.CompletedPageCounts[searchOrder]++;
									}
									else
									{
										errMessage = updateResult.Message;
										// 作業用のデータセットのレコードを削除
										searchResultBuf.Tables[0].Rows.Clear();
										bReturn = false;
									}
								}
								else
								{
									errMessage = "検索結果キャッシュの追加に失敗しました。" + procMessage;
									// 作業用のデータセットのレコードを削除
									searchResultBuf.Tables[0].Rows.Clear();
									bReturn = false;
								}
							}
							else
							{
								errMessage = "検索結果のデータ圧縮に失敗しました。";
								bReturn = false;
							}
						}
					}
					else
					{
						// 結果が1件以上の場合
						// データセットをフォーマットする
						CreateSearchResultBuff(dr, columnNameList, displayNameList, targetColumnTypes, numericDateTimeFormats, out searchResultBuf);

						// データ読み込みループ開始
						while (!m_cancelRequest && bReturn && dr.Read())
						{
							// 読み込みカウンタをインクリメント
							m_dataCntList[searchOrder]++;

							if (m_dataCntList[searchOrder] > m_maxDataCnt)
							{
								errCode = CANWErrCode.TooManyDataCnt;
								errMessage = "該当する件数が多すぎます。" + m_maxDataCnt.ToString() + " 件以下になるように、検索条件の絞り込みを行ってください。";
								bReturn = false;
								break;
							}
							else
							{
								// データセットに１レコード追加する
								AddDataRow(dr, searchResultBuf.Tables[0], columnNameList, numericDateTimeFormats);

								// 1ページの終端なので、とりためたデータをDBに書き込む
								if (m_dataCntList[searchOrder] % m_divisionRange == 0)
								{
									resultOrder++;

									if (CompressDataSet(searchResultBuf, out searchResultComp))
									{
										// 進捗更新およびキャンセルチェック
										if (SetProgressRate(searchOrder, resultOrder, 6) && m_cancelRequest)
										{
											bReturn = false;    // キャンセル
											break;
										}
										else if (ClinicalSearchCoreLibs.AddSearchResultCache(cmdWrite, searchHistoryId, resultOrder, searchResultComp, loginId, out procMessage))
										{
											var updateResult = ClinicalSearchCoreLibs.UpdateSearchHistory(cmdWrite, searchHistoryId, this.m_dataCntList[searchOrder], resultOrder);
											if (updateResult.Code == CANWErrCode.Success)
											{
												//上位に結果をマージして戻す
												screeningSearchResult.Merge(searchResultBuf.Tables[0]);
												// とりためたデータを削除
												searchResultBuf.Tables[0].Rows.Clear();

												// 完了ページ数を更新
												this.CompletedPageCounts[searchOrder]++;
											}
											else
											{
												errMessage = updateResult.Message;
												// とりためたデータを削除
												searchResultBuf.Tables[0].Rows.Clear();
												bReturn = false;
												break;
											}
										}
										else
										{
											errMessage = "検索結果キャッシュの追加に失敗しました。" + procMessage;
											// とりためたデータを削除
											searchResultBuf.Tables[0].Rows.Clear();
											bReturn = false;
											break;
										}
									}
									else
									{
										// SearchLogに理由を記載して終了
										errMessage = "検索結果のデータ圧縮に失敗しました。";
										// とりためたデータを削除
										searchResultBuf.Tables[0].Rows.Clear();
										bReturn = false;
										break;
									}
								}
							}
						}   // note : データ読み込みループ終端

						// 進捗更新およびキャンセルチェック
						if (SetProgressRate(searchOrder, resultOrder, 7) && m_cancelRequest)
						{
							bReturn = false; // キャンセル;
						}
						else if (bReturn)
						{
							// ループ終了時にsearchResultBuff.Tables[0]にデータが1件でもあれば、ここで登録する
							if (searchResultBuf.Tables[0].Rows.Count > 0)
							{
								resultOrder++;

								if (CompressDataSet(searchResultBuf, out searchResultComp))
								{
									if (ClinicalSearchCoreLibs.AddSearchResultCache(cmdWrite, searchHistoryId, resultOrder, searchResultComp, loginId, out procMessage))
									{
										var updateResult = ClinicalSearchCoreLibs.UpdateSearchHistory(cmdWrite, searchHistoryId, this.m_dataCntList[searchOrder], resultOrder);
										if (updateResult.Code == CANWErrCode.Success)
										{
											//上位に結果をマージして戻す
											screeningSearchResult.Merge(searchResultBuf.Tables[0]);
											// 作業用のデータセットのレコードを削除
											searchResultBuf.Tables[0].Rows.Clear();

											this.CompletedPageCounts[searchOrder]++;
										}
										else
										{
											errMessage = updateResult.Message;
											// 作業用のデータセットのレコードを削除
											searchResultBuf.Tables[0].Rows.Clear();
											bReturn = false;
										}
									}
									else
									{
										errMessage = "検索結果キャッシュの追加に失敗しました。" + procMessage;
										// 作業用のデータセットのレコードを削除
										searchResultBuf.Tables[0].Rows.Clear();
										bReturn = false;
									}
								}
								else
								{
									errMessage = "検索結果のデータ圧縮に失敗しました。";
									bReturn = false;
								}
								searchResultBuf.Tables[0].Rows.Clear();
							}
						}
					}
					// 最後に検索履歴のデータ件数と履歴分割数を更新する
					if (bReturn && !m_cancelRequest)
					{
						m_successSearchOrders.Add(searchOrder);
					}
				}
			}
			catch (CanDbException ex)
			{
				bReturn = false;

				// note : DB2の場合に問い合わせたSQLのコストが高いためDBの処理がタイムアウトするとこの例外が投げられることがあるのでここで対応する
				if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "HY008"))
				{
					errCode = CANWErrCode.Timeout;
					errMessage = ex.Message;
				}
				// note : DB2の場合に問い合わせたSQLが長すぎるもしくは複雑すぎるとこの例外が投げられることがあるのでここで対応する
				else if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "54001"))
				{
					errCode = CANWErrCode.TooLargeRequest;
					errMessage = ex.Message;
				}
				else
				{
					errCode = CANWErrCode.System;
					errMessage = ex.Message;
				}
			}
			finally
			{
				if (dr != null) { dr.Close(); }
			}

			return bReturn;
		}

		/// <summary>
		/// スクリーニング検索時SQL実行を行ないScreeningSearchPart_TBLへレコードを追加する関数
		/// </summary>
		/// <param name="cmdRead">読み込み用のDBコネクション</param>
		/// <param name="cmdWrite">書き込み用のDBコネクション</param>
		/// <param name="dr">データリーダー</param>
		/// <param name="selectSql">セレクトSQL</param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="loginId">ログインID</param>
		/// <param name="columnNameList">カラム項目一覧</param>
        /// <param name="displayNameList">表示名称一覧</param>
        /// <param name="targetColumnTypes">ターゲット項目型一覧</param>
        /// <param name="numericDateTimeFormats">数値型日付フォーマット一覧</param>
		/// <param name="errCode">エラーコード</param>
		/// <param name="errMessage">エラーメッセージ</param>
		/// <returns>正常処理フラグ</returns>
		private bool ReadDataAndInsertScreeningSearchPart(CanDbCommand cmdRead,
                                                                CanDbCommand cmdWrite,
                                                                CanDbDataReader dr,
                                                                string selectSql,
                                                                long searchHistoryId,
                                                                int searchOrder,
                                                                string loginId,
                                                                string[] columnNameList,
                                                                string[] displayNameList,
                                                                string[] targetColumnTypes,
                                                                NumericDateTimeFormat[] numericDateTimeFormats,
                                                                out DataTable screeningSearchResult,
                                                                out CANWErrCode errCode,
                                                                out string errMessage)
		{
			bool bReturn = true;
			DataSet partResult = null;
			byte[] partResultComp = null;
			int resultOrder = 0;
			string procMessage = "";

			errCode = CANWErrCode.Success;
			errMessage = "";
			screeningSearchResult = new DataTable();

			try
			{
				// 結果を取得する
				if (dr != null) { dr.Close(); }
				cmdRead.Parameters.Clear();
				cmdRead.CommandText = selectSql;
				dr = SqlLibs.ExecuteReader(cmdRead, this);

				// SQL 実行がキャンセルされた
				if (this.CancelRequest)
				{
					bReturn = false;
#if UNITTEST
                    errMessage = "検索処理を途中でキャンセルしました";
#endif
				}
				// SQL 実行が完了
				else
				{
					m_dataCntList[searchOrder] = 0;

					// 結果が0件の場合
					if (dr.HasRows == false)
					{
						// データセットをフォーマットする
						CreateSearchResultBuff(dr, columnNameList, displayNameList, targetColumnTypes, numericDateTimeFormats, out partResult);
						// DataReaderクリア
						if (dr != null) { dr.Close(); }

						// 進捗更新およびキャンセルチェック
						if (SetProgressRate(searchOrder, resultOrder, 6) && m_cancelRequest)
						{
							bReturn = false;    // キャンセル;
						}
						else
						{
							resultOrder++;

							if (CompressDataSet(partResult, out partResultComp))
							{
								// 進捗更新およびキャンセルチェック
								if (SetProgressRate(searchOrder, resultOrder, 6) && m_cancelRequest)
								{
									bReturn = false;    // キャンセル
								}
								else if (ClinicalSearchCoreLibs.AddScreeningSearchPartResult(cmdWrite, searchHistoryId, searchOrder, resultOrder, partResultComp, loginId, 
                                    out procMessage))
								{
									var updateResult = ClinicalSearchCoreLibs.UpdateScreeningSearchPart(cmdWrite, searchHistoryId, searchOrder, 
                                        this.m_dataCntList[searchOrder], resultOrder);
									if (updateResult.Code == CANWErrCode.Success)
									{
										//上位に結果をマージして戻す
										screeningSearchResult.Merge(partResult.Tables[0]);
										// 作業用のデータセットのレコードを削除
										partResult.Tables[0].Rows.Clear();

										// 完了ページ数を更新
										this.CompletedPageCounts[searchOrder]++;
									}
									else
									{
										errMessage = updateResult.Message;
										// 作業用のデータセットのレコードを削除
										partResult.Tables[0].Rows.Clear();
										bReturn = false;
									}
								}
								else
								{
									errMessage = "検索結果キャッシュの追加に失敗しました。" + procMessage;
									// 作業用のデータセットのレコードを削除
									partResult.Tables[0].Rows.Clear();
									bReturn = false;
								}
							}
							else
							{
								errMessage = "検索結果のデータ圧縮に失敗しました。";
								bReturn = false;
							}
						}
					}
					else
					{
						// 結果が1件以上の場合
						// データセットをフォーマットする
						CreateSearchResultBuff(dr, columnNameList, displayNameList, targetColumnTypes, numericDateTimeFormats, out partResult);

						// データ読み込みループ開始
						while (!m_cancelRequest && bReturn && dr.Read())
						{
							// 読み込みカウンタをインクリメント
							m_dataCntList[searchOrder]++;

							if (m_dataCntList[searchOrder] > m_maxDataCnt)
							{
								errCode = CANWErrCode.TooManyDataCnt;
								errMessage = "該当する件数が多すぎます。" + m_maxDataCnt.ToString() + " 件以下になるように、検索条件の絞り込みを行ってください。";
								bReturn = false;
								break;
							}
							else
							{
								// データセットに１レコード追加する
								AddDataRow(dr, partResult.Tables[0], columnNameList, numericDateTimeFormats);

								// 1ページの終端なので、とりためたデータをDBに書き込む
								if (m_dataCntList[searchOrder] % m_divisionRange == 0)
								{
									resultOrder++;

									if (CompressDataSet(partResult, out partResultComp))
									{
										// 進捗更新およびキャンセルチェック
										if (SetProgressRate(searchOrder, resultOrder, 6) && m_cancelRequest)
										{
											bReturn = false;    // キャンセル
											break;
										}
										else if (ClinicalSearchCoreLibs.AddScreeningSearchPartResult(cmdWrite, searchHistoryId, searchOrder, resultOrder, partResultComp, loginId, 
                                            out procMessage))
										{
											var updateResult = ClinicalSearchCoreLibs.UpdateScreeningSearchPart(cmdWrite, searchHistoryId, searchOrder, 
                                                this.m_dataCntList[searchOrder], resultOrder);
											if (updateResult.Code == CANWErrCode.Success)
											{
												//上位に結果をマージして戻す
												screeningSearchResult.Merge(partResult.Tables[0]);
												// とりためたデータを削除
												partResult.Tables[0].Rows.Clear();

												this.CompletedPageCounts[searchOrder]++;
											}
											else
											{
												errMessage = updateResult.Message;
												// とりためたデータを削除
												partResult.Tables[0].Rows.Clear();
												bReturn = false;
												break;
											}
										}
										else
										{
											errMessage = "検索結果キャッシュの追加に失敗しました。" + procMessage;
											// とりためたデータを削除
											partResult.Tables[0].Rows.Clear();
											bReturn = false;
											break;
										}
									}
									else
									{
										// SearchLogに理由を記載して終了
										errMessage = "検索結果のデータ圧縮に失敗しました。";
										// とりためたデータを削除
										partResult.Tables[0].Rows.Clear();
										bReturn = false;
										break;
									}
								}
							}
						}   // note : データ読み込みループ終端

						// 進捗更新およびキャンセルチェック
						if (SetProgressRate(searchOrder, resultOrder, 7) && m_cancelRequest)
						{
							bReturn = false;    // キャンセル
						}
						else if (bReturn)
						{
							// ループ終了時にsearchResultBuff.Tables[0]にデータが1件でもあれば、ここで登録する
							if (partResult.Tables[0].Rows.Count > 0)
							{
								resultOrder++;

								if (CompressDataSet(partResult, out partResultComp))
								{
									if (ClinicalSearchCoreLibs.AddScreeningSearchPartResult(cmdWrite, searchHistoryId, searchOrder, resultOrder, partResultComp, loginId, 
                                        out procMessage))
									{
										var updateResult = ClinicalSearchCoreLibs.UpdateScreeningSearchPart(cmdWrite, searchHistoryId, searchOrder, 
                                            this.m_dataCntList[searchOrder], resultOrder);
										if (updateResult.Code == CANWErrCode.Success)
										{
											//上位に結果をマージして戻す
											screeningSearchResult.Merge(partResult.Tables[0]);
											// 作業用のデータセットのレコードを削除
											partResult.Tables[0].Rows.Clear();

											this.CompletedPageCounts[searchOrder]++;
										}
										else
										{
											errMessage = updateResult.Message;
											// とりためたデータを削除
											partResult.Tables[0].Rows.Clear();
											bReturn = false;
										}
									}
									else
									{
										errMessage = "検索結果キャッシュの追加に失敗しました。" + procMessage;
										// 作業用のデータセットのレコードを削除
										partResult.Tables[0].Rows.Clear();
										bReturn = false;
									}
								}
								else
								{
									errMessage = "検索結果のデータ圧縮に失敗しました。";
									bReturn = false;
								}
								partResult.Tables[0].Rows.Clear();
							}
						}
					}
					// 最後に検索履歴のデータ件数と履歴分割数を更新する
					if (bReturn && !m_cancelRequest)
					{
						//					// 検索履歴を更新
						//					if (!ClinicalSearchCoreLibs.UpdateScreeningSearchPartDataCnt(cmdWrite, searchHistoryId, searchOrder, m_dataCntList[searchOrder], resultOrder, out procMessage))
						//					{
						//						bReturn = false;
						//						errMessage = procMessage;
						//					}
						//					else
						//					{
						// 成功
						m_successSearchOrders.Add(searchOrder);
						//					}
					}
				}
			}
			catch (CanDbException ex)
			{
				bReturn = false;
				// note : DB2の場合に問い合わせたSQLのコストが高いためDBの処理がタイムアウトするとこの例外が投げられることがあるのでここで対応する
				if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "HY008"))
				{
					errCode = CANWErrCode.Timeout;
					errMessage = ex.Message;
				}
				// note : DB2の場合に問い合わせたSQLが長すぎるもしくは複雑すぎるとこの例外が投げられることがあるのでここで対応する
				else if ((ex.Errors[0] != null) && (ex.Errors[0].SQLState == "54001"))
				{
					errCode = CANWErrCode.TooLargeRequest;
					errMessage = ex.Message;
				}
				else
				{
					errCode = CANWErrCode.System;
					errMessage = ex.Message;
				}
			}
			finally
			{
				if (dr != null) { dr.Close(); }
			}

			return bReturn;
		}

		/// <summary>
		/// 結果データテーブルに行を追加する
		/// </summary>
		/// <param name="dr">データリーダー</param>
		/// <param name="searchResultDataTable">検索結果データテーブル</param>
        /// <param name="columnNameList">項目名一覧</param>
        /// <param name="numericDateTimeFormats">数値型日付フォーマット一覧</param>
		private void AddDataRow(CanDbDataReader dr, DataTable searchResultDataTable, string[] columnNameList, NumericDateTimeFormat[] numericDateTimeFormats)
		{
			DataRow		dRow;

			int		col = 0;
			dRow = searchResultDataTable.NewRow();
			for (col = 0; col < searchResultDataTable.Columns.Count; col++)
			{
                // DataTable 側が文字列
				if (searchResultDataTable.Columns[col].DataType == typeof(string))
				{
					// note : 文字列型の場合はトリムする（結果表示のため）
					dRow[col] = (!dr.IsDBNull(col)) ? dr[col].ToString().Trim() : dr[col];
				}
                // DataTable 側が日付(数値型日付は既に変更されているのでここ)
                else if (searchResultDataTable.Columns[col].DataType == typeof(DateTime))
				{
                    // 項目名が一致する項目名一覧の場所を取得
                    int index = columnNameList.ToList().IndexOf(searchResultDataTable.Columns[col].ColumnName.ToUpper());
                    // フォーマット指定なし
                    if (numericDateTimeFormats[index] == NumericDateTimeFormat.None)
                    {
                        dRow[col] = dr[col];
                    }
                    else
                    {
                        // 数値を日付フォーマットを指定して日付型に変換して格納
                        dRow[col] = ToDateTime(dr[col].ToString(), numericDateTimeFormats[index]);
                    }
				}
                // DataTable 側が数値
                else
                {
                    dRow[col] = dr[col];
                }
			}
			searchResultDataTable.Rows.Add(dRow);

			return;
		}


        /// <summary>
        /// 数値型日時を日時に変換
        /// </summary>
        /// <param name="value">SQL で取得できた値</param>
        /// <param name="numericDateTimeFormat">数値型日時フォーマット</param>
        /// <returns>検索結果に格納する日付</returns>
        private DateTime ToDateTime(string value, NumericDateTimeFormat numericDateTimeFormat)
        {
            DateTime date;

            // 日付または日時に変換できればそのまま格納
            if (DateTime.TryParseExact(value, numericDateTimeFormat.ToString(), null, System.Globalization.DateTimeStyles.None, out date))
            {
                // 正常に変換できたためそのまま返す。
            }
            // 年 4 桁の日時
            else if (numericDateTimeFormat == NumericDateTimeFormat.yyyyMMddHHmmss)
            {
                if (value.Length != 14)
                {
                    date = GetDateForInvalidValue(value, numericDateTimeFormat);
                }
                // 年月日は日付に変換できるか確認
                else if (DateTime.TryParseExact(value.Substring(0, 8), "yyyyMMdd", null, System.Globalization.DateTimeStyles.None, out date))
                {
                    // 年月日が DateTime の最大値未満かつ、時刻が 24 時の場合は上で変換した日付の翌日の 0 時に補正
                    if (date.Date < DateTime.MaxValue.Date &&
                            value.Substring(8, 6) == "240000")
                    {
                        date = new DateTime(date.AddDays(1).Year, date.AddDays(1).Month, date.AddDays(1).Day, 0, 0, 0);
                    }
                    // 年月日が DateTime の最大値または、時刻が 24 時以外の場合は、決められた日付を取得
                    else
                    {
                        date = GetDateForInvalidValue(value, numericDateTimeFormat);
                    }
                }
                // 年月日が日付に変換できない場合は、決められた日付を取得
                else
                {
                    date = GetDateForInvalidValue(value, numericDateTimeFormat);
                }
            }
            // 日付または日時に変換できない場合は、決められた日付を取得
            else
            {
                date = GetDateForInvalidValue(value, numericDateTimeFormat);
            }

            return date;
        }


        /// <summary>
        /// 日付として無効な値の場合、決められた日付を取得
        /// </summary>
        /// <param name="invalidValue">日付としては無効な値</param>
        /// <param name="numericDateTimeFormat">数値型日時フォーマット</param>
        /// <returns>決められた日付</returns>
        private DateTime GetDateForInvalidValue(string invalidValue, NumericDateTimeFormat numericDateTimeFormat)
        {
            DateTime date;

            long value = (invalidValue == string.Empty) ? 0 : long.Parse(invalidValue);
            // 年 4 桁日付
            if (numericDateTimeFormat == NumericDateTimeFormat.yyyyMMdd)
            {
                // 20000000 未満は、1899-01-01 00:00:00 へ
                if (value < 20000000)
                {
                    date = new DateTime(1899, 1, 1, 0, 0, 0);
                }
                // 20000000 以上は、2199-12-31 00:00:00 へ(23:59:59 にすると表示の際に時刻が表示されてしまう)
                else
                {
                    date = new DateTime(2199, 12, 31, 0, 0, 0);
                }
            }
            // 年 4 桁日時
            else if (numericDateTimeFormat == NumericDateTimeFormat.yyyyMMddHHmmss)
            {
                // 20000000000000 未満は、1899-01-01 00:00:00 へ
                if (value < 20000000000000)
                {
                    date = new DateTime(1899, 1, 1, 0, 0, 0);
                }
                // 20000000000000 以上は、2199-12-31 23:59:59 へ
                else
                {
                    date = new DateTime(2199, 12, 31, 23, 59, 59);
                }
            }
            // その他のフォーマット(yyMMdd, yyMMddHHmmss, HHmmss)は DEV_CAN-1920 では使用しないため、この処理は想定されないが、限界値を設定する
            else
            {
                date = new DateTime(9999, 12, 31, 23, 59, 59);
            }

            return date;
        }


		/// <summary>
        /// ProgressRateを更新する
		/// </summary>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="resultOrder"></param>
		/// <param name="stepNo"></param>
		/// <returns></returns>
		private bool SetProgressRate(int searchOrder, int resultOrder, int stepNo)
		{

			int		progressRate = 0;
			double	orderRate = 0;

			if (stepNo == 0)
			{
				progressRate = 0;
			}
			else if (stepNo == 1)
			{
				progressRate = 2;
			}
			else if (stepNo == 2)
			{
				progressRate = 4;
			}
			else if (stepNo == 3)
			{
				progressRate = 6;
			}
			else if (stepNo == 4)
			{
				progressRate = 8;
			}
			else if (stepNo == 5)
			{
				progressRate = 10;
			}
			else if (stepNo == 6)
			{
				if (resultOrder <= m_maxResultOrder / 2)
				{
					orderRate = resultOrder * 1.5 / m_maxResultOrder * 90.0;
				}
				else
				{
					orderRate = ((m_maxResultOrder / 2) * 1.5 + (resultOrder - (m_maxResultOrder / 2)) * 0.5) / m_maxResultOrder * 90.0;
				}
				progressRate = (10 + (int)orderRate > 100) ? 100 : 10 + (int)orderRate;
			}
			else
			{
				progressRate = 100;
			}

			if (m_progressRateList.Count > searchOrder)
			{
				m_progressRateList[searchOrder] = progressRate;
			}
			else
			{
				m_progressRateList.Add(progressRate);
			}

			return true;		// note : 処理のため常にTrueを返す
		}

		/// <summary>
		/// データ件数の配列を追加します
		/// </summary>
		/// <param name="searchOrder">検索順序</param>
		/// <param name="dataCnt">データ件数</param>
		/// <returns></returns>
		private bool AddDataCnt(int searchOrder, int dataCnt)
		{
			if (m_dataCntList.Count > searchOrder)
			{
				m_dataCntList[searchOrder] = dataCnt;
			}
			else
			{
				m_dataCntList.Add(dataCnt);
			}
			return true;
		}

		/// <summary>
		/// SearchRelationCache_TBLの該当行を削除する処理
		/// </summary>
		/// <param name="cmd"></param>
		/// <param name="searchHistoryId">検索履歴ID</param>
		/// <param name="errMessage"></param>
		/// <returns></returns>
		private bool DeleteSearchRelationCacheProc(CanDbCommand cmd, long searchHistoryId, out string errMessage)
		{
			bool		bReturn = false;

			errMessage = "";
			try
			{
				cmd.Parameters.Clear();
				cmd.CommandText = "delete from SearchRelationCache_TBL where SearchHistoryId=?";
				cmd.Parameters.Add("@SearchHistoryId", CanDbType.Integer).Value = searchHistoryId;
				cmd.ExecuteNonQuery();

				bReturn = true;
			}
			catch (CanDbException ex)
			{
				errMessage = ex.Message;
			}
			return bReturn;
		}

		/// <summary>
		/// 検索結果データセットを初期化して作成する
		/// </summary>
		/// <param name="dr">データリーダ</param>
		/// <param name="columnNameList">項目名一覧</param>
		/// <param name="displayNameList">表示名一覧</param>
        /// <param name="targetColumnTypes">ターゲット項目型一覧</param>
        /// <param name="numericDateTimeFormats">数値型日付フォーマット一覧</param>
		/// <param name="searchResultBuff">検索結果用データセット</param>
		private void CreateSearchResultBuff(CanDbDataReader dr, string[] columnNameList, string[] displayNameList, string[] targetColumnTypes, NumericDateTimeFormat[] numericDateTimeFormats, out DataSet searchResultBuff)
		{
			DataTable	dTable = new DataTable();
			DataColumn	dColumn = new DataColumn();
			int			i, ii;
			bool		sameColumnNameStatus;

			searchResultBuff = new DataSet();
			dTable = searchResultBuff.Tables.Add();

			i = 0;
			for (i = 0; i < dr.FieldCount; i++)
			{
				dColumn = dTable.Columns.Add();
				dColumn.ColumnName = dr.GetName(i);
				dColumn.DataType = dr.GetFieldType(i);
			}

			i = ii = 0;
			for (i = 0; i < dTable.Columns.Count; i++)
			{
				sameColumnNameStatus = false;
				for (ii = 0; ii < columnNameList.Length; ii++)
				{
					if (dTable.Columns[i].ColumnName.ToUpper().Trim() == columnNameList[ii].Trim())
					{
						dTable.Columns[i].Caption = displayNameList[ii];

                        // 数値型日付の場合は型を修正
                        if (targetColumnTypes[ii] == "DATE")
                        {
                            // フォーマット指定が存在したら日付型に変更する
// ToDo : DEV_CAN-1920 で、年2桁フォーマットについては、問題が発生したため、対応しないこととする。
//   (2000年01月10日を扱おうとするとでーたとしては 110 となってしまい、補正する必要があるが対応する時間がない。)
// ToDo : DEV_CAN-1920 で、時刻のみのフォーマットについては TargetBuilder で選択できないようにしたため、テストは実施していない。
                            if (numericDateTimeFormats[ii] == NumericDateTimeFormat.yyMMdd ||
                                    numericDateTimeFormats[ii] == NumericDateTimeFormat.yyyyMMdd ||
                                    numericDateTimeFormats[ii] == NumericDateTimeFormat.yyMMddHHmmss ||
                                    numericDateTimeFormats[ii] == NumericDateTimeFormat.yyyyMMddHHmmss ||
                                    numericDateTimeFormats[ii] == NumericDateTimeFormat.HHmmss)
                            {
                                dTable.Columns[i].DataType = typeof(DateTime);
                            }
                        }

						sameColumnNameStatus = true;
						break;
					}
					if (!sameColumnNameStatus)
					{
						dTable.Columns[i].Caption = dTable.Columns[i].ColumnName;
					}
				}
			}
			return;
        }

		/// <summary>
		/// 指定ターゲットのカラム名と表示名を同期して取得する
		/// </summary>
        /// <param name="conn">DBコネクション</param>
		/// <param name="targetId">ターゲットID</param>
        /// <param name="targetDisplayName">ターゲット表示名</param>
        /// <param name="columnNameList">項目名一覧</param>
        /// <param name="displayNameList">表示名一覧</param>
		/// <param name="originalColumnTypes">元のデータ型一覧</param>
        /// <param name="errMessage">エラーメッセージ</param>
        /// <returns>TRUE:取得できる/FALSE：取得できない</returns>
		private bool GetDisplayNameListProc(CanDbConnection conn,
                                                long targetId,
                                                out string targetDisplayName,
                                                out string[] columnNameList,
                                                out string[] displayNameList,
                                                out string[] targetColumnTypes,
                                                out NumericDateTimeFormat[] numericDateTimeFormats,
												out string[] originalColumnTypes,
                                                out string errMessage)
		{

			bool				bReturn = false;
			CanDbCommand		cmd;
			CanDbDataReader		dr = null;
			List<string>		columnNameListBuff = new List<string>();
			List<string>		displayNameListBuff = new List<string>();

            var targetColumnTypesBuffer = new List<string>();
            var numericDateTimeFormatsBuffer = new List<NumericDateTimeFormat>();
			List<string> originalColumnTypesBuffer = new List<string>();

			targetDisplayName = "";
			columnNameList = null;
			displayNameList = null;

            targetColumnTypes = null;
            numericDateTimeFormats = null;
			originalColumnTypes = null;

			errMessage = "";

			try
			{
				cmd = new CanDbCommand("", conn, null);
				cmd.CommandText = "select DisplayName from Target_TBL where TargetId=?";
				cmd.Parameters.Add("@TargetId", CanDbType.Integer).Value = targetId;
				dr = cmd.ExecuteReader();
				if (dr.HasRows && dr.Read())
				{
					targetDisplayName = SqlLibs.GetStringValueByDataReader(dr, 0);
					dr.Close();
					cmd.Parameters.Clear();
					cmd.CommandText = "select ColumnName, DisplayName, ColumnType, NumericDateTimeFormat from TargetColumn_TBL where TargetId = ? order by DisplayOrder asc";
					cmd.Parameters.Add("@TargetId", CanDbType.Integer).Value = targetId;
					dr = cmd.ExecuteReader();
					if (dr.HasRows)
					{
						while (dr.Read())
						{
							columnNameListBuff.Add(dr["ColumnName"].ToString().ToUpper());
							displayNameListBuff.Add(dr["DisplayName"].ToString());
							originalColumnTypesBuffer.Add(dr["ColumnType"].ToString().ToUpper());

                            switch (dr["ColumnType"].ToString().ToUpper())
                            {
                                case "STRING":
                                case "VALUE":
									switch (dr["NumericDateTimeFormat"].ToString().ToUpper())
                                    {
                                        // 設定なし→数値
                                        case "NONE":
                                            targetColumnTypesBuffer.Add(dr["ColumnType"].ToString().ToUpper());
                                            numericDateTimeFormatsBuffer.Add(NumericDateTimeFormat.None);
                                            break;
// ToDo : DEV_CAN-1920 で、年2桁フォーマットについては、問題が発生したため、対応しないこととする。
// (2000年01月10日を扱おうとするとでーたとしては 110 となってしまい、補正する必要があるが対応する時間がない。)
                                        // 数値型日付
                                        case "YYMMDD":
                                            targetColumnTypesBuffer.Add("DATE");
                                            numericDateTimeFormatsBuffer.Add(NumericDateTimeFormat.yyMMdd);
                                            break;
                                        // 数値型日付
                                        case "YYYYMMDD":
                                            targetColumnTypesBuffer.Add("DATE");
                                            numericDateTimeFormatsBuffer.Add(NumericDateTimeFormat.yyyyMMdd);
                                            break;
// ToDo : DEV_CAN-1920 で、年2桁フォーマットについては、問題が発生したため、対応しないこととする。
// (2000年01月10日を扱おうとするとでーたとしては 110 となってしまい、補正する必要があるが対応する時間がない。)
                                        // 数値型日付
                                        case "YYMMDDHHMMSS":
                                            targetColumnTypesBuffer.Add("DATE");
                                            numericDateTimeFormatsBuffer.Add(NumericDateTimeFormat.yyMMddHHmmss);
                                            break;
                                        // 数値型日付
                                        case "YYYYMMDDHHMMSS":
                                            targetColumnTypesBuffer.Add("DATE");
                                            numericDateTimeFormatsBuffer.Add(NumericDateTimeFormat.yyyyMMddHHmmss);
                                            break;
// ToDo : DEV_CAN-1920 で、時刻のみのフォーマットについては TargetBuilder で選択できないようにしたため、テストは実施していない。
                                        // 数値型日付
                                        case "HHMMSS":
                                            targetColumnTypesBuffer.Add("DATE");
                                            numericDateTimeFormatsBuffer.Add(NumericDateTimeFormat.HHmmss);
                                            break;
                                    }
                                    break;
                                case "DATE":
                                    targetColumnTypesBuffer.Add(dr["ColumnType"].ToString().ToUpper());
                                    numericDateTimeFormatsBuffer.Add(NumericDateTimeFormat.None);
                                    break;
                            }
						}
					}
					if (columnNameListBuff.Count > 0 && displayNameListBuff.Count > 0)
					{
						columnNameList = columnNameListBuff.ToArray();
						displayNameList = displayNameListBuff.ToArray();
                        targetColumnTypes = targetColumnTypesBuffer.ToArray();
                        numericDateTimeFormats = numericDateTimeFormatsBuffer.ToArray();
						originalColumnTypes = originalColumnTypesBuffer.ToArray();
					}
					cmd.Parameters.Clear();
					bReturn = true;
				}
			}
			catch (CanDbException ex)
			{
				errMessage = ex.Message;
			}
			finally
			{
				if (dr != null) { dr.Close(); }
			}

			return bReturn;
		}

		/// <summary>
		/// DataSetを圧縮して返す
		/// </summary>
		/// <param name="dataSet">データセット</param>
		/// <param name="dataSetComp">圧縮されたデータセット</param>
		/// <returns></returns>
		private bool CompressDataSet(DataSet dataSet, out byte[] dataSetComp)
		{
			bool		retValue = true;
			string		dataSetXml;
			dataSetComp = null;

			SerializeDataSet(dataSet, out dataSetXml);

			retValue = ArcLib.CompressZipData(System.Text.Encoding.GetEncoding(932).GetBytes(dataSetXml), out dataSetComp);
			return retValue;
		}

		/// <summary>
		/// DataSetタイプのオブジェクトをシリアライズする
		/// </summary>
		/// <param name="dataSet">データセット</param>
		/// <param name="dataSetXml">[out]シリアライズされたデータセット</param>
		private void SerializeDataSet(DataSet dataSet, out string dataSetXml)
		{
			TextWriter		tw = new StringWriter();
			XmlSerializer	serializer;

			dataSetXml = "";

			serializer = new XmlSerializer(typeof(DataSet));
			serializer.Serialize(tw, dataSet);
			dataSetXml = tw.ToString();

			return;
		}


        /// <summary>
        /// 検索エージェント完了時コールバックメソッド
        /// </summary>
        /// <param name="iAsyncResult">非同期ステータス</param>
        private void CompletedAgent(IAsyncResult iAsyncResult)
        {
            // キャンセルされていた場合のみ、EndInvoke を行う。
            if (this.CancelRequest)
            {
                // 引数ではなく、Agent の 非同期ステータスが NULL 以外、かつ、完了(コールバックであるため未完了は無いと思うが)している場合のみ
                if (this.IAsyncResult != null &&
                        this.IAsyncResult.IsCompleted)
                {
                    this.m_searchDelegate.EndInvoke(this.IAsyncResult);
                }
            }
            // キャンセルされずに完了した Agent は Check～ メソッドで EndInvoke を行うため、ここでは行わない。
            else
            {

            }
		}

		/// <summary>
		/// キャンセル
		/// </summary>
		public void Cancel()
		{
			// SQL Command が 生成済みの場合、キャンセル
			if (this.ReadCommand != null)
			{
				this.m_cancelRequest = true;
				this.ReadCommand.Cancel();
			}
		}
	}
}